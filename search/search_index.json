{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\udde0 Data Structures &amp; Algorithms (Java)","text":"<p>Welcome to the DSA Notes site! This documentation covers essential concepts and algorithms in computer science, with examples in Java.</p> <p>Whether you're preparing for interviews, improving problem-solving skills, or just exploring DSA, this guide is for you.</p>"},{"location":"#topics-covered","title":"\ud83d\udcda Topics Covered","text":""},{"location":"#linear-data-structures","title":"\ud83d\udd39 Linear Data Structures","text":"<ul> <li>Array</li> <li>String</li> <li>Stack</li> <li>Queue</li> <li>Linked List</li> </ul>"},{"location":"#non-linear-data-structures","title":"\ud83c\udf32 Non-Linear Data Structures","text":"<ul> <li>Tree</li> <li>Graph</li> <li>Trie</li> </ul>"},{"location":"#algorithms","title":"\u2699\ufe0f Algorithms","text":"<ul> <li>Dynamic Programming</li> <li>Greedy Algorithm</li> </ul>"},{"location":"#techniques-math","title":"\ud83e\uddee Techniques &amp; Math","text":"<ul> <li>Maths</li> <li>Bit Manipulation</li> </ul>"},{"location":"#highlights","title":"\ud83d\udccc Highlights","text":"<ul> <li>\u2705 Clean Java code examples</li> <li>\u2705 Covers foundational to advanced topics</li> <li>\u2705 Structured for quick reference</li> <li>\u2705 Ideal for competitive programming &amp; interviews</li> </ul> <p>\ud83d\udea7 This documentation is a work in progress. Contributions and improvements are welcome!</p>"},{"location":"array/","title":"Array","text":""},{"location":"array/#key-concepts","title":"Key Concepts","text":"<ul> <li>Fixed size, index-based data structure</li> <li>Stored in contiguous memory</li> </ul>"},{"location":"array/#common-problems","title":"Common Problems","text":"<ul> <li>Two Sum</li> <li>Kadane's Algorithm</li> <li>Sliding Window Maximum</li> <li>Merge Intervals</li> </ul>"},{"location":"array/#techniques-patterns","title":"Techniques / Patterns","text":"<ul> <li>Two Pointers</li> <li>Sliding Window</li> <li>Prefix Sum</li> </ul>"},{"location":"array/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"array/#easy","title":"Easy","text":"<ul> <li>Two Sum</li> <li>Maximum Subarray</li> <li>Best Time to Buy and Sell Stock</li> <li>Contains Duplicate</li> <li>Single Number</li> <li>Intersection of Two Arrays II</li> <li>Plus One</li> <li>Move Zeroes</li> <li>Rotate Array</li> <li>Find Pivot Index</li> </ul>"},{"location":"array/#medium","title":"Medium","text":"<ul> <li>3Sum</li> <li>Set Matrix Zeroes</li> <li>Group Anagrams</li> <li>Product of Array Except Self</li> <li>Top K Frequent Elements</li> <li>Sort Colors</li> <li>Find All Numbers Disappeared in an Array</li> </ul>"},{"location":"array/#hard","title":"Hard","text":"<ul> <li>First Missing Positive</li> <li>Trapping Rain Water</li> <li>Merge Intervals</li> <li>Insert Interval</li> <li>Longest Consecutive Sequence</li> <li>Median of Two Sorted Arrays</li> <li>Maximum Product Subarray</li> </ul>"},{"location":"array/#resources","title":"Resources","text":"<ul> <li>LeetCode Array Problems</li> <li>HackerRank Arrays</li> <li>HackerEarth Array Practice</li> </ul>"},{"location":"bit-manipulation/","title":"Bit Manipulation","text":""},{"location":"bit-manipulation/#key-concepts","title":"Key Concepts","text":"<ul> <li>Operations at bit-level for speed and space</li> </ul>"},{"location":"bit-manipulation/#common-problems","title":"Common Problems","text":"<ul> <li>Check if number is power of 2</li> <li>Count set bits</li> <li>Single number in an array</li> </ul>"},{"location":"bit-manipulation/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"bit-manipulation/#easy","title":"Easy","text":"<ul> <li>Single Number</li> </ul>"},{"location":"bit-manipulation/#medium","title":"Medium","text":"<ul> <li>Sum of Two Integers</li> <li>Counting Bits</li> </ul>"},{"location":"bit-manipulation/#hard","title":"Hard","text":"<ul> <li>Maximum XOR of Two Numbers in an Array</li> </ul>"},{"location":"bit-manipulation/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Bit Manipulation</li> </ul>"},{"location":"dynamic-programming/","title":"Dynamic Programming","text":""},{"location":"dynamic-programming/#key-concepts","title":"Key Concepts","text":"<ul> <li>Solves overlapping subproblems</li> <li>Optimal substructure</li> </ul>"},{"location":"dynamic-programming/#common-problems","title":"Common Problems","text":"<ul> <li>Fibonacci Sequence</li> <li>Longest Common Subsequence</li> <li>0/1 Knapsack</li> </ul>"},{"location":"dynamic-programming/#techniques","title":"Techniques","text":"<ul> <li>Memoization (Top-Down)</li> <li>Tabulation (Bottom-Up)</li> </ul>"},{"location":"dynamic-programming/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":"<ul> <li>Climbing Stairs: similar to fibonacci</li> <li>Frog Jump: Similar to above just need to subtract energy to jump (frog need to reach end)<ul> <li>Que: [10,20,30,10] Ans: 20</li> </ul> </li> </ul> <pre><code>      public class ClimbStairsOptimized {\n         public int climbStairs(int n, int arr) {\n\n            int first = 0;\n            int second = 0;\n\n            for (int i = 1; i &lt; n; i++) {\n                  int fs = first + Math.abs(arr[i] - arr[i-1]); // jumping 1 step\n                  int ss = Integer.MAX_VALUE;\n                  if(i&gt;1) ss = second + Math.abs(arr[i] - arr[i-2]); // jumping 2 steps\n\n                  int temp = Math.min(fs, ss); // taking min or max based on question\n                  second = first; \n                  first = temp;\n            }\n\n            return first;\n         }\n      }\n</code></pre> <ul> <li>Frog Jump to K distance: similar to above problem, just one change before we were doing for step 1 and step 2, now we will do till k steps meaning we will iterate min/max logic in a for loop and get the result</li> </ul> <pre><code>for (int i = 1; i &lt; n; i++) {\n   int minSteps = Integer.MAX_VALUE;\n   for(int j = 1; j &lt;= k; j++&gt;) {\n      int ss = Integer.MAX_VALUE;\n      if(i-j&gt;=0) ss = dp[i-j] + Math.abs(arr[i] - arr[i-j]);\n      minSteps = Math.min(fs, ss)\n   }\n   dp[i] = minSteps;\n}\n</code></pre> <ul> <li>Maximum sum of non Adjecent elements: Here as the questions says we can't use contiguos elements for adding up the numbers. So what we do is we start with the classic DP approach of subsequence, where we add element by the take or notTake approach, and solve the problem <ul> <li>Que: [2,1,4,9] Ans: 11</li> </ul> </li> </ul> <pre><code>fun(3, arr);\n\nint fun(int i, int[] arr) {\n   if(i&lt;0) return 0;\n   if(i == 0) return arr[0];\n\n   int take = arr[i] + fun(i-2, arr); // takes the element and will take the next+1 element\n   int notTake = fun(i-1, arr); // does not take, basically says we can take next element\n\n   return Math.max(take, notTake); // return the max value\n}\n</code></pre> <ul> <li>House Robber: Similar to above</li> <li>House Robber 2: Similar to above, here we can't take the first and last element, so we call the method 2 times with [0, n-2] and [1, n-1], means skipping first one time and last second, and then taking max or min as per the expectation</li> <li>Grid Unique Paths</li> <li>Grid Unique Paths 2</li> <li>Min Path Sum</li> <li>Max Path Sum</li> <li>Triangle : Most of these problems will start at a certain index and then move to another in (i-1, j), (i, j-1) or (i-1,j-1) paths. based on questions these change but the core concept remains the same of take and notTake.</li> <li>Cherry Pickup 2 [3D Array]: <ul> <li>Similar to above here 2 start points will be given, core logic remains the same just a change is that when 2 paths collide we will take a single value from both. Also here in function we will have 3 vars instead of 2. Here row remains the same as both start from first row but start index is different that's why. Ending points can be similar, that's why we will take one value if they reach at same index and will take different value if they reach at different indexes. </li> <li>Now as we need to generate all the combinations for 3 pointers we will need a for loop which will start from first person -1 to +1 value and same for second as well.</li> </ul> </li> </ul> <pre><code>\n  return dp(grid, 0, 0, n - 1, mem);\n\n  public int cherryPickup(int[][] grid) {\n    final int m = grid.length;\n    final int n = grid[0].length;\n    int[][][] mem = new int[m][n][n];\n    Arrays.stream(mem).forEach(A -&gt; Arrays.stream(A).forEach(B -&gt; Arrays.fill(B, -1)));\n    return dp(grid, 0, 0, n - 1, mem);\n  }\n\n  // Returns the maximum cherries we can collect, where robot #1 is on (x, y1) and robot #2 is on (x, y2).\n  private int dp(int[][] grid, int x, int y1, int y2, int[][][] mem) {\n    if (x == grid.length) // end of rows\n      return 0;\n    if (y1 &lt; 0 || y1 == grid[0].length || y2 &lt; 0 || y2 == grid[0].length) // out of bounds case\n      return 0;\n    if (mem[x][y1][y2] != -1)\n      return mem[x][y1][y2];\n\n    final int currRow = grid[x][y1] + (y1 == y2 ? 0 : grid[x][y2]); // checking if both match then don't add and take one otherwise add both\n\n    for (int d1 = -1; d1 &lt;= 1; d1++)\n      for (int d2 = -1; d2 &lt;= 1; d2++)\n        mem[x][y1][y2] = Math.max(mem[x][y1][y2], currRow + dp(grid, x + 1, y1 + d1, y2 + d2, mem)); // calling all the 9 combinations here for d1 and d2\n\n    return mem[x][y1][y2];\n  }\n\n</code></pre> <ul> <li>Subset sum equal to K: Mostly similar to problem 4 just that this is 2D, here we will have index and sum and 2 params for our DP. whenever we pass the values just make sure if we are taking it then f(i-1,sum-arr[index]) will be passed otherwise f(i-1, sum) will be passed. Small cases will be added that sum should not be negative when subtracting. </li> <li>Partition Equal Subset Sum:<ul> <li>Que: [2,3,3,3,4,5] must be divided to equal sum &gt; [2,3,5] &amp; [3,3,4]</li> <li>Approach: For this first calculate the total sum fo the array, if sum%2==0 then we can divide it and follow the above problem with Sum as sum/2 and we are good.</li> </ul> </li> <li>Partition A Set Into Two Subsets With Minimum Absolute Sum Difference: This is similar to subset sum problem, where we have create a boolean array which will tell us whether we can get the target sum or not. Now next step is to iterate through the optimized dp solution and subtract s2 = totalSum - s1 and s1 will get the final min value.</li> </ul> <pre><code>   for(int s1 = 0; s1&lt;=totalSum/2;s1++){\n      if(dp[lastRow][s1] == true) // subset sum is possible that means true\n         min = Math.min(min, (totalSum-s1) - s1) // basically saying s2 - s1; as the data will be stored as [0,3,5,7,9,12], for s1 it is from begining and for s2 it from end. \n   }\n</code></pre> <ul> <li>Counts Subsets with Sum K: Similar to problem 12, just we need to all the results if it matches with the sum.</li> <li>Count Partitions With Given Difference:  Similar to problem 12, just a minor change the sum that we will be finding is = (totalSum - diff) / 2</li> <li>0/1 Knapsack: similar to problem 12, here we will be subtracting the weight from the weight capacity of bag, it will break once the loop reaches to end for items.</li> <li>Coin change: Similar to above, just that when we are taking a coin it is not moved to next index for take case if it is less than total value, only for not take case it moved to next index. And as always when we are taking a value that means we need to subtract that value from totalValue. If it reaches to zero then that means we have reached to final.</li> <li>Target Sum: Similar to 16, just a change here is questions is talking about + and - signs which basically means dividing the data into 2 sets.</li> <li>Coin Change 2 | Infinite Supply Problems: Asking for how many ways we can make the amount, just add take and notTake and we will be good.</li> <li>Unbounded Knapsack: Same as coin change problem</li> <li>Rod Cutting Problem: Similar to 0/1 Knapsack problem</li> <li>Longest Common Subsequence: This also follows the approach of match and not match, but here as this is a String problem we will be adding few more cases.</li> </ul> <pre><code>s1 = \"adcbc\", s2 = \"dcadb\"\nif(s1.charAt(i) == s.charAt(j))\n   return 1 + f(i-1, j-1, arr); // As the char matches we go to previous index at both strings\n\nreturn Math.max(f(i, j-1, arr), f(i-1, j, arr)); // char is not matching at index so we go for previous index for s1 and second call for s2 saying that, may be they can match\n</code></pre> <ul> <li>Print Longest Common Subsequence: Similar to above question, go for the optimized solution for above question and then we need to iterate through the dp array with below conditions. Single loop should be enough and start from last indexes of both Strings.<ul> <li>If they match then go to i-1, j-1</li> <li>If they don't match then if dp[i-1][j] &gt; dp[i][j] then i--; else j--;</li> </ul> </li> <li>Longest Common Substring: Similar to LCS problem just that the notTake part is not considered as we want subString not sequence</li> <li>Longest Palindromic Subsequence: Similar to LCS, here for string 2 we need to reverse the original String and send it.</li> <li>Minimum Insertions to Make String Palindrome: Similar to LCS, get the count of above program and subtract from the total size of original string</li> <li>Minimum Insertions/Deletions to Convert String A to String B: s1.size() + s2.size() - 2 * LCS of both</li> <li>Shortest Common Supersequence: <ul> <li>Que : s1=\"brute\", s2=\"groot\" Result: \"bgruoote\"</li> <li>Ans: </li> <li>Approach is similar to 24, just one change is previously we were just printing matching chars now we will add them even if they don't match.</li> <li>But post that there is a chance that data will still remain in either of those strings so lets add that as well to the result.</li> </ul> </li> </ul> <pre><code>s1 = \"brute\", s2 = \"groot\"\nwhile(i&gt;0 &amp;&amp; j&gt;0) {\n   if(s1.charAt(i-1) == s2.charAt(j-1)) { // if matched then add and reduce both indexes\n      result += s1.charAt(i-1);\n      i--;\n      j--;\n   } else if(dp[i-1][j] &gt; dp[i][j]) { // if d[i-1][j] &gt; dp[i][j] then add from first string\n      result += s1.charAt(i-1);\n      i--;\n   }else {\n      result += s2.charAt(j-1); // add from second string\n      j--;\n   }\n}\n\nwhile(i&gt;0) result += s1.charAt(i-1); i--; // add the remaining chars from string 1\nwhile(j&gt;0) result += s2.charAt(j-1); j--; // add the remaining chars from string 2\n</code></pre> <ul> <li>Distinct Subsequences: As part of this problem we need to find that how many times string 2 is present in string 1 as a subsequence, there is a slight change with this problem here.<ul> <li>if the char matches on both string we can consider the index from first string or we can ignore that, means (i-1, j-1) + (i-1, j) </li> <li>if they don't match just move the first string cause we need to match the first string with second so we do (i-1, j)</li> </ul> </li> </ul> <pre><code>s1 = \"babgbag\", s2 = \"bag\"\n\nif(j&lt;0) return 1; // basically saying s2 is exhausted \nif(i&lt;0) return 0; // nothing to compare \n\nif(s1.charAt(i) == s.charAt(j))\n   return f(i-1, j-1, arr) + f(i-1, j, arr); \n\nreturn f(i-1, j, arr); // char is not matching at index so we go for previous index for s1\n</code></pre>"},{"location":"graph/","title":"Graph","text":""},{"location":"graph/#key-concepts","title":"Key Concepts","text":"<ul> <li>Set of vertices connected by edges</li> <li>Directed/Undirected, Weighted/Unweighted</li> </ul>"},{"location":"graph/#common-problems","title":"Common Problems","text":"<ul> <li>BFS, DFS traversal</li> <li>Detect Cycle</li> <li>Dijkstra's Algorithm</li> </ul>"},{"location":"graph/#algorithms-techniques","title":"Algorithms / Techniques","text":"<ul> <li>BFS, DFS</li> <li>Union-Find</li> <li>Topological Sort</li> </ul>"},{"location":"graph/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"graph/#easy","title":"\u2705 Easy","text":"<ol> <li> <p>Find the Town Judge    Identify a town judge based on trust relationships.</p> </li> <li> <p>Number of Islands    Count connected islands in a grid using DFS/BFS.</p> </li> <li> <p>Flood Fill    Change connected pixels of the same color.</p> </li> <li> <p>Max Area of Island    Find largest connected island area.</p> </li> <li> <p>Clone Graph    Create a deep copy of a graph.</p> </li> </ol>"},{"location":"graph/#medium","title":"\ud83d\udd01 Medium","text":"<ol> <li> <p>Course Schedule    Detect if it\u2019s possible to finish all courses (cycle detection).</p> </li> <li> <p>Number of Connected Components in an Undirected Graph    Count connected components in a graph.</p> </li> <li> <p>Pacific Atlantic Water Flow    Cells from which water flows to both oceans.</p> </li> <li> <p>Alien Dictionary    Find character order from alien dictionary words.</p> </li> <li> <p>Graph Valid Tree    Determine if edges make a valid tree.</p> </li> <li> <p>Number of Islands II    Count islands as land is added dynamically.</p> </li> <li> <p>Word Ladder    Shortest transformation sequence from start to end word.</p> </li> <li> <p>Minimum Height Trees    Find roots of trees with minimum height.</p> </li> </ol>"},{"location":"graph/#hard","title":"\ud83d\udd25 Hard","text":"<ol> <li> <p>Word Ladder II    Find all shortest transformation sequences.</p> </li> <li> <p>Critical Connections in a Network    Find bridges in a network (Tarjan\u2019s algorithm).</p> </li> <li> <p>Reconstruct Itinerary    Rebuild travel itinerary using all tickets.</p> </li> <li> <p>Alien Dictionary II (Similar to Alien Dictionary but more complex variants)</p> </li> <li> <p>Longest Increasing Path in a Matrix    Longest strictly increasing path in a matrix.</p> </li> <li> <p>Cheapest Flights Within K Stops    Find cheapest flight with at most k stops.</p> </li> <li> <p>Shortest Path in a Grid with Obstacles Elimination    Shortest path allowing to eliminate obstacles.</p> </li> </ol>"},{"location":"graph/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Graph Problems</li> <li>HackerRank Graph Theory</li> </ul>"},{"location":"greedy/","title":"Greedy Algorithm","text":""},{"location":"greedy/#key-concepts","title":"Key Concepts","text":"<ul> <li>Local optimal choice leads to global optimum</li> </ul>"},{"location":"greedy/#common-problems","title":"Common Problems","text":"<ul> <li>Activity Selection</li> <li>Fractional Knapsack</li> <li>Jump Game</li> </ul>"},{"location":"greedy/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"greedy/#easy","title":"\u2705 Easy","text":"<ol> <li> <p>Assign Cookies    Assign cookies to children with greedily matching sizes.</p> </li> <li> <p>Jump Game    Determine if you can jump to the last index.</p> </li> <li> <p>Gas Station    Find start point to complete a circular route.</p> </li> <li> <p>Best Time to Buy and Sell Stock    Maximize profit from a single buy/sell.</p> </li> </ol>"},{"location":"greedy/#medium","title":"\ud83d\udd01 Medium","text":"<ol> <li> <p>Partition Labels    Partition a string into as many parts as possible without repeating letters.</p> </li> <li> <p>Task Scheduler    Schedule tasks with cooldown intervals.</p> </li> <li> <p>Jump Game II    Minimum number of jumps to reach the last index.</p> </li> <li> <p>Queue Reconstruction by Height    Reconstruct queue based on height and people in front.</p> </li> <li> <p>Candy    Distribute candies with rules on ratings.</p> </li> </ol>"},{"location":"greedy/#hard","title":"\ud83d\udd25 Hard","text":"<ol> <li> <p>Merge Triplets to Form Target Triplet    Determine if target triplet can be formed from triplets.</p> </li> <li> <p>Minimum Number of Refueling Stops    Minimum stops to reach destination with refueling constraints.</p> </li> <li> <p>Split Array Largest Sum (often solved by binary search + greedy)    Split array to minimize largest sum among subarrays.</p> </li> <li> <p>Largest Divisible Subset    Find largest subset where every pair is divisible.</p> </li> </ol>"},{"location":"greedy/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Greedy Problems</li> </ul>"},{"location":"linked-list/","title":"Linked List","text":""},{"location":"linked-list/#key-concepts","title":"Key Concepts","text":"<ul> <li>Nodes pointing to next element</li> <li>Singly, Doubly, and Circular Linked Lists</li> </ul>"},{"location":"linked-list/#common-problems","title":"Common Problems","text":"<ul> <li>Reverse a Linked List</li> <li>Detect Cycle</li> <li>Merge Two Sorted Lists</li> </ul>"},{"location":"linked-list/#patterns-techniques","title":"Patterns / Techniques","text":"<ul> <li>Fast and Slow Pointers</li> <li>Recursion</li> </ul>"},{"location":"linked-list/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"linked-list/#easy","title":"\u2705 Easy","text":"<ol> <li> <p>Reverse Linked List    Reverse a singly linked list.</p> </li> <li> <p>Merge Two Sorted Lists    Merge two sorted linked lists into one.</p> </li> <li> <p>Delete Node in a Linked List    Delete a node given only access to that node.</p> </li> <li> <p>Remove Nth Node From End of List    Remove the nth node from the end of the list.</p> </li> <li> <p>Linked List Cycle    Detect if a linked list has a cycle.</p> </li> </ol>"},{"location":"linked-list/#medium","title":"\ud83d\udd01 Medium","text":"<ol> <li> <p>Add Two Numbers    Add two numbers represented by linked lists.</p> </li> <li> <p>Sort List    Sort a linked list in O(n log n) time.</p> </li> <li> <p>Copy List with Random Pointer    Deep copy of a linked list with random pointers.</p> </li> <li> <p>Reorder List    Reorder list to a specific sequence.</p> </li> <li> <p>Remove Duplicate from Sorted List II    Remove all duplicates from a sorted linked list.</p> </li> </ol>"},{"location":"linked-list/#hard","title":"\ud83d\udd25 Hard","text":"<ol> <li> <p>Merge k Sorted Lists    Merge k sorted linked lists.</p> </li> <li> <p>Reverse Nodes in k-Group    Reverse nodes in groups of k.</p> </li> <li> <p>LRU Cache (uses linked list + hashmap)    Design a least recently used cache.</p> </li> <li> <p>Split Linked List in Parts    Split linked list into k parts.</p> </li> <li> <p>Copy List with Random Pointer (if considered hard due to pointers)</p> </li> </ol>"},{"location":"linked-list/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Linked List Problems</li> <li>HackerRank Linked Lists</li> </ul>"},{"location":"maths/","title":"Maths","text":""},{"location":"maths/#key-concepts","title":"Key Concepts","text":"<ul> <li>Number theory: GCD, LCM, Primes</li> <li>Modulo operations</li> </ul>"},{"location":"maths/#common-problems","title":"Common Problems","text":"<ul> <li>Sieve of Eratosthenes</li> <li>Modular Exponentiation</li> <li>Count Digits / Bits</li> </ul>"},{"location":"maths/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"maths/#easy","title":"Easy","text":"<ul> <li>Count Primes</li> </ul>"},{"location":"maths/#medium","title":"Medium","text":"<ul> <li>Power of Three</li> <li>Add Digits</li> </ul>"},{"location":"maths/#hard","title":"Hard","text":"<ul> <li>Integer to English Words</li> </ul>"},{"location":"maths/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Math Problems</li> </ul>"},{"location":"queue/","title":"Queue","text":""},{"location":"queue/#key-concepts","title":"Key Concepts","text":"<ul> <li>FIFO (First In First Out)</li> <li>Enqueue and Dequeue operations</li> </ul>"},{"location":"queue/#common-problems","title":"Common Problems","text":"<ul> <li>Implement Queue using Stacks</li> <li>Circular Queue</li> <li>Sliding Window Maximum</li> </ul>"},{"location":"queue/#patterns-techniques","title":"Patterns / Techniques","text":"<ul> <li>Two Stacks for Queue</li> <li>Double-ended Queue (Deque)</li> </ul>"},{"location":"queue/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"queue/#easy","title":"Easy","text":"<ul> <li>Implement Queue using Stacks</li> <li>Number of Recent Calls</li> </ul>"},{"location":"queue/#medium","title":"Medium","text":"<ul> <li>Perfect Squares</li> <li>Dota2 Senate</li> </ul>"},{"location":"queue/#hard","title":"Hard","text":"<ul> <li>Sliding Window Maximum</li> </ul>"},{"location":"queue/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Queue Problems</li> <li>HackerRank Queues</li> </ul>"},{"location":"stack/","title":"Stack","text":""},{"location":"stack/#key-concepts","title":"Key Concepts","text":"<ul> <li>LIFO (Last In First Out)</li> <li>Push and Pop operations</li> </ul>"},{"location":"stack/#common-problems","title":"Common Problems","text":"<ul> <li>Valid Parentheses</li> <li>Next Greater Element</li> <li>Min Stack</li> </ul>"},{"location":"stack/#patterns-techniques","title":"Patterns / Techniques","text":"<ul> <li>Monotonic Stack</li> <li>Stack with auxiliary structures</li> </ul>"},{"location":"stack/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"stack/#easy","title":"Easy","text":"<ul> <li>Valid Parentheses</li> <li>Min Stack</li> </ul>"},{"location":"stack/#medium","title":"Medium","text":"<ul> <li>Evaluate Reverse Polish Notation</li> <li>Daily Temperatures</li> <li>Asteroid Collision</li> <li>Decode String</li> </ul>"},{"location":"stack/#hard","title":"Hard","text":"<ul> <li>Largest Rectangle in Histogram</li> <li>Maximal Rectangle</li> </ul>"},{"location":"stack/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Stack Problems</li> <li>HackerRank Stacks</li> <li>Code360 Stack Questions</li> </ul>"},{"location":"string/","title":"String","text":""},{"location":"string/#key-concepts","title":"Key Concepts","text":"<ul> <li>Immutable sequences of characters</li> <li>Efficient manipulation using StringBuilder</li> <li>Character arrays for performance</li> </ul>"},{"location":"string/#common-problems","title":"Common Problems","text":"<ul> <li>Longest Substring Without Repeating Characters</li> <li>Anagram Check</li> <li>Palindromic Substrings</li> <li>String Compression</li> </ul>"},{"location":"string/#patterns-techniques","title":"Patterns / Techniques","text":"<ul> <li>Sliding Window</li> <li>Two Pointers</li> <li>Hashing</li> </ul>"},{"location":"string/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"string/#easy","title":"\u2705 Easy","text":"<ol> <li> <p>Valid Anagram    Check if two strings are anagrams.</p> </li> <li> <p>Implement strStr()    Find the index of the first occurrence of a substring.</p> </li> <li> <p>Reverse String    Reverse a string in-place.</p> </li> <li> <p>First Unique Character in a String    Find the first non-repeating character.</p> </li> <li> <p>Valid Palindrome    Check if a string is a palindrome ignoring non-alphanumeric chars.</p> </li> </ol>"},{"location":"string/#medium","title":"\ud83d\udd01 Medium","text":"<ol> <li> <p>Longest Substring Without Repeating Characters    Find length of longest substring with unique characters.</p> </li> <li> <p>Group Anagrams    Group strings that are anagrams.</p> </li> <li> <p>Longest Palindromic Substring    Find the longest palindromic substring.</p> </li> <li> <p>Count and Say    Generate the nth term of the count-and-say sequence.</p> </li> <li> <p>Decode String    Decode strings with nested patterns like \"3[a2[c]]\".</p> </li> <li> <p>Minimum Window Substring    Find minimum window substring containing all characters of another string.</p> </li> </ol>"},{"location":"string/#hard","title":"\ud83d\udd25 Hard","text":"<ol> <li> <p>Wildcard Matching    Implement wildcard pattern matching with <code>?</code> and <code>*</code>.</p> </li> <li> <p>Regular Expression Matching    Match strings with regex patterns.</p> </li> <li> <p>Substring with Concatenation of All Words    Find starting indices of substrings formed by concatenating all words.</p> </li> <li> <p>Edit Distance    Compute minimum operations to convert one string to another.</p> </li> <li> <p>Longest Valid Parentheses    Find the length of the longest valid (well-formed) parentheses substring.</p> </li> </ol>"},{"location":"tree/","title":"Tree","text":""},{"location":"tree/#key-concepts","title":"Key Concepts","text":"<ul> <li>Hierarchical structure with nodes</li> <li>Binary Tree, BST, Balanced Trees</li> </ul>"},{"location":"tree/#common-problems","title":"Common Problems","text":"<ul> <li>Tree Traversals (Inorder, Preorder, Postorder)</li> <li>Maximum Depth</li> <li>Lowest Common Ancestor</li> </ul>"},{"location":"tree/#patterns-techniques","title":"Patterns / Techniques","text":"<ul> <li>Recursion</li> <li>DFS, BFS</li> </ul>"},{"location":"tree/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"tree/#easy","title":"\u2705 Easy","text":"<ol> <li> <p>Maximum Depth of Binary Tree    Find the height of a binary tree.</p> </li> <li> <p>Symmetric Tree    Check if a tree is a mirror of itself.</p> </li> <li> <p>Invert Binary Tree    Flip the tree upside down.</p> </li> <li> <p>Binary Tree Paths    Find all root-to-leaf paths.</p> </li> <li> <p>Path Sum    Check if there\u2019s a root-to-leaf path with a given sum.</p> </li> </ol>"},{"location":"tree/#medium","title":"\ud83d\udd01 Medium","text":"<ol> <li> <p>Binary Tree Inorder Traversal    Inorder traversal of a tree (recursive and iterative).</p> </li> <li> <p>Construct Binary Tree from Preorder and Inorder Traversal    Rebuild tree from traversal data.</p> </li> <li> <p>Lowest Common Ancestor of a Binary Search Tree    Find LCA in a BST.</p> </li> <li> <p>Serialize and Deserialize Binary Tree    Convert tree to string and back.</p> </li> <li> <p>Populating Next Right Pointers in Each Node    Connect nodes at the same level.</p> </li> </ol>"},{"location":"tree/#hard","title":"\ud83d\udd25 Hard","text":"<ol> <li> <p>Binary Tree Maximum Path Sum    Find max path sum between any two nodes.</p> </li> <li> <p>Recover Binary Search Tree    Fix swapped nodes in BST.</p> </li> <li> <p>Count of Smaller Numbers After Self    Count smaller elements to the right.</p> </li> <li> <p>Longest Consecutive Sequence    Find longest consecutive path.</p> </li> <li> <p>Word Ladder II (involves graph/tree BFS)</p> </li> </ol>"},{"location":"tree/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Tree Problems</li> <li>HackerRank Trees</li> </ul>"},{"location":"trie/","title":"Trie","text":""},{"location":"trie/#key-concepts","title":"Key Concepts","text":"<ul> <li>Prefix tree structure</li> <li>Efficient for search, autocomplete</li> </ul>"},{"location":"trie/#common-problems","title":"Common Problems","text":"<ul> <li>Insert and Search Word</li> <li>Prefix Matching</li> </ul>"},{"location":"trie/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"trie/#medium","title":"Medium","text":"<ul> <li>Implement Trie (Prefix Tree)</li> <li>Replace Words</li> </ul>"},{"location":"trie/#hard","title":"Hard","text":"<ul> <li>Word Search II</li> <li>Palindrome Pairs</li> </ul>"},{"location":"trie/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Trie Problems</li> </ul>"}]}