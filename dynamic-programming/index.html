
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../graph/">
      
      
        <link rel="next" href="../stack/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.14">
    
    
      
        <title>Dynamic Programming - DSA Notes</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.342714a4.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#dynamic-programming" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="DSA Notes" class="md-header__button md-logo" aria-label="DSA Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            DSA Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Dynamic Programming
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="DSA Notes" class="md-nav__button md-logo" aria-label="DSA Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    DSA Notes
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../array/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Array
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    String
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../tree/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Tree
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Graph
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Dynamic Programming
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Dynamic Programming
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#key-concepts" class="md-nav__link">
    <span class="md-ellipsis">
      Key Concepts
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#common-problems" class="md-nav__link">
    <span class="md-ellipsis">
      Common Problems
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#techniques" class="md-nav__link">
    <span class="md-ellipsis">
      Techniques
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#practice-problems-by-topic" class="md-nav__link">
    <span class="md-ellipsis">
      ðŸ”¹ Practice Problems by Topic
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../stack/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Stack
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../queue/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Queue
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../linked-list/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Linked List
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../trie/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Trie
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../maths/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Maths
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../bit-manipulation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Bit Manipulation
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../greedy/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Greedy Algorithm
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#key-concepts" class="md-nav__link">
    <span class="md-ellipsis">
      Key Concepts
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#common-problems" class="md-nav__link">
    <span class="md-ellipsis">
      Common Problems
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#techniques" class="md-nav__link">
    <span class="md-ellipsis">
      Techniques
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#practice-problems-by-topic" class="md-nav__link">
    <span class="md-ellipsis">
      ðŸ”¹ Practice Problems by Topic
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="dynamic-programming">Dynamic Programming</h1>
<h2 id="key-concepts">Key Concepts</h2>
<ul>
<li>Solves overlapping subproblems</li>
<li>Optimal substructure</li>
</ul>
<h2 id="common-problems">Common Problems</h2>
<ul>
<li>Fibonacci Sequence</li>
<li>Longest Common Subsequence</li>
<li>0/1 Knapsack</li>
</ul>
<h2 id="techniques">Techniques</h2>
<ul>
<li>Memoization (Top-Down)</li>
<li>Tabulation (Bottom-Up)</li>
</ul>
<h2 id="practice-problems-by-topic">ðŸ”¹ Practice Problems by Topic</h2>
<ul>
<li><strong>Climbing Stairs</strong>: similar to fibonacci</li>
<li><strong>Frog Jump</strong>: Similar to above just need to subtract energy to jump (frog need to reach end)<ul>
<li>Que: [10,20,30,10] Ans: 20</li>
</ul>
</li>
</ul>
<pre><code class="language-java">      public class ClimbStairsOptimized {
         public int climbStairs(int n, int arr) {

            int first = 0;
            int second = 0;

            for (int i = 1; i &lt; n; i++) {
                  int fs = first + Math.abs(arr[i] - arr[i-1]); // jumping 1 step
                  int ss = Integer.MAX_VALUE;
                  if(i&gt;1) ss = second + Math.abs(arr[i] - arr[i-2]); // jumping 2 steps

                  int temp = Math.min(fs, ss); // taking min or max based on question
                  second = first; 
                  first = temp;
            }

            return first;
         }
      }
</code></pre>
<ul>
<li><strong>Frog Jump to K distance</strong>: similar to above problem, just one change before we were doing for step 1 and step 2, now we will do till k steps meaning we will iterate min/max logic in a for loop and get the result</li>
</ul>
<pre><code class="language-java">for (int i = 1; i &lt; n; i++) {
   int minSteps = Integer.MAX_VALUE;
   for(int j = 1; j &lt;= k; j++&gt;) {
      int ss = Integer.MAX_VALUE;
      if(i-j&gt;=0) ss = dp[i-j] + Math.abs(arr[i] - arr[i-j]);
      minSteps = Math.min(fs, ss)
   }
   dp[i] = minSteps;
}
</code></pre>
<ul>
<li><strong>Maximum sum of non Adjecent elements</strong>: Here as the questions says we can't use contiguos elements for adding up the numbers. So what we do is we start with the classic DP approach of subsequence, where we add element by the take or notTake approach, and solve the problem <ul>
<li>Que: [2,1,4,9] Ans: 11</li>
</ul>
</li>
</ul>
<pre><code class="language-java">fun(3, arr);

int fun(int i, int[] arr) {
   if(i&lt;0) return 0;
   if(i == 0) return arr[0];

   int take = arr[i] + fun(i-2, arr); // takes the element and will take the next+1 element
   int notTake = fun(i-1, arr); // does not take, basically says we can take next element

   return Math.max(take, notTake); // return the max value
}
</code></pre>
<ul>
<li><strong>House Robber</strong>: Similar to above</li>
<li><strong>House Robber 2</strong>: Similar to above, here we can't take the first and last element, so we call the method 2 times with [0, n-2] and [1, n-1], means skipping first one time and last second, and then taking max or min as per the expectation</li>
<li><strong>Grid Unique Paths</strong></li>
<li><strong>Grid Unique Paths 2</strong></li>
<li><strong>Min Path Sum</strong></li>
<li><strong>Max Path Sum</strong></li>
<li><strong>Triangle</strong> : Most of these problems will start at a certain index and then move to another in (i-1, j), (i, j-1) or (i-1,j-1) paths. based on questions these change but the core concept remains the same of take and notTake.</li>
<li><strong>Cherry Pickup 2 [3D Array]</strong>: <ul>
<li>Similar to above here 2 start points will be given, core logic remains the same just a change is that when 2 paths collide we will take a single value from both. Also here in function we will have 3 vars instead of 2. Here row remains the same as both start from first row but start index is different that's why. Ending points can be similar, that's why we will take one value if they reach at same index and will take different value if they reach at different indexes. </li>
<li>Now as we need to generate all the combinations for 3 pointers we will need a for loop which will start from first person -1 to +1 value and same for second as well.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">
  return dp(grid, 0, 0, n - 1, mem);

  public int cherryPickup(int[][] grid) {
    final int m = grid.length;
    final int n = grid[0].length;
    int[][][] mem = new int[m][n][n];
    Arrays.stream(mem).forEach(A -&gt; Arrays.stream(A).forEach(B -&gt; Arrays.fill(B, -1)));
    return dp(grid, 0, 0, n - 1, mem);
  }

  // Returns the maximum cherries we can collect, where robot #1 is on (x, y1) and robot #2 is on (x, y2).
  private int dp(int[][] grid, int x, int y1, int y2, int[][][] mem) {
    if (x == grid.length) // end of rows
      return 0;
    if (y1 &lt; 0 || y1 == grid[0].length || y2 &lt; 0 || y2 == grid[0].length) // out of bounds case
      return 0;
    if (mem[x][y1][y2] != -1)
      return mem[x][y1][y2];

    final int currRow = grid[x][y1] + (y1 == y2 ? 0 : grid[x][y2]); // checking if both match then don't add and take one otherwise add both

    for (int d1 = -1; d1 &lt;= 1; d1++)
      for (int d2 = -1; d2 &lt;= 1; d2++)
        mem[x][y1][y2] = Math.max(mem[x][y1][y2], currRow + dp(grid, x + 1, y1 + d1, y2 + d2, mem)); // calling all the 9 combinations here for d1 and d2

    return mem[x][y1][y2];
  }

</code></pre>
<ul>
<li><strong>Subset sum equal to K</strong>: Mostly similar to problem 4 just that this is 2D, here we will have index and sum and 2 params for our DP. whenever we pass the values just make sure if we are taking it then f(i-1,sum-arr[index]) will be passed otherwise f(i-1, sum) will be passed. Small cases will be added that sum should not be negative when subtracting. </li>
<li><strong>Partition Equal Subset Sum</strong>:<ul>
<li>Que: [2,3,3,3,4,5] must be divided to equal sum &gt; [2,3,5] &amp; [3,3,4]</li>
<li>Approach: For this first calculate the total sum fo the array, if sum%2==0 then we can divide it and follow the above problem with Sum as sum/2 and we are good.</li>
</ul>
</li>
<li><strong>Partition A Set Into Two Subsets With Minimum Absolute Sum Difference</strong>: This is similar to subset sum problem, where we have create a boolean array which will tell us whether we can get the target sum or not. Now next step is to iterate through the optimized dp solution and subtract s2 = totalSum - s1 and s1 will get the final min value.</li>
</ul>
<pre><code class="language-java">   for(int s1 = 0; s1&lt;=totalSum/2;s1++){
      if(dp[lastRow][s1] == true) // subset sum is possible that means true
         min = Math.min(min, (totalSum-s1) - s1) // basically saying s2 - s1; as the data will be stored as [0,3,5,7,9,12], for s1 it is from begining and for s2 it from end. 
   }
</code></pre>
<ul>
<li><strong>Counts Subsets with Sum K</strong>: Similar to problem 12, just we need to all the results if it matches with the sum.</li>
<li><strong>Count Partitions With Given Difference</strong>:  Similar to problem 12, just a minor change the sum that we will be finding is = (totalSum - diff) / 2</li>
<li><strong>0/1 Knapsack</strong>: similar to problem 12, here we will be subtracting the weight from the weight capacity of bag, it will break once the loop reaches to end for items.</li>
<li><strong>Coin change</strong>: Similar to above, just that when we are taking a coin it is not moved to next index for take case if it is less than total value, only for not take case it moved to next index. And as always when we are taking a value that means we need to subtract that value from totalValue. If it reaches to zero then that means we have reached to final.</li>
<li><strong>Target Sum</strong>: Similar to 16, just a change here is questions is talking about + and - signs which basically means dividing the data into 2 sets.</li>
<li><strong>Coin Change 2 | Infinite Supply Problems</strong>: Asking for how many ways we can make the amount, just add take and notTake and we will be good.</li>
<li><strong>Unbounded Knapsack</strong>: Same as coin change problem</li>
<li><strong>Rod Cutting Problem</strong>: Similar to 0/1 Knapsack problem</li>
<li><strong>Longest Common Subsequence</strong>: This also follows the approach of match and not match, but here as this is a String problem we will be adding few more cases.</li>
</ul>
<pre><code class="language-java">s1 = &quot;adcbc&quot;, s2 = &quot;dcadb&quot;
if(s1.charAt(i) == s.charAt(j))
   return 1 + f(i-1, j-1, arr); // As the char matches we go to previous index at both strings

return Math.max(f(i, j-1, arr), f(i-1, j, arr)); // char is not matching at index so we go for previous index for s1 and second call for s2 saying that, may be they can match
</code></pre>
<ul>
<li><strong>Print Longest Common Subsequence</strong>: Similar to above question, go for the optimized solution for above question and then we need to iterate through the dp array with below conditions. Single loop should be enough and start from last indexes of both Strings.<ul>
<li>If they match then go to i-1, j-1</li>
<li>If they don't match then if dp[i-1][j] &gt; dp[i][j] then i--; else j--;</li>
</ul>
</li>
<li><strong>Longest Common Substring</strong>: Similar to LCS problem just that the notTake part is not considered as we want subString not sequence</li>
<li><strong>Longest Palindromic Subsequence</strong>: Similar to LCS, here for string 2 we need to reverse the original String and send it.</li>
<li><strong>Minimum Insertions to Make String Palindrome</strong>: Similar to LCS, get the count of above program and subtract from the total size of original string</li>
<li><strong>Minimum Insertions/Deletions to Convert String A to String B</strong>: s1.size() + s2.size() - 2 * LCS of both</li>
<li><strong>Shortest Common Supersequence</strong>: <ul>
<li>Que : s1="brute", s2="groot" Result: "bgruoote"</li>
<li>Ans: </li>
<li>Approach is similar to 24, just one change is previously we were just printing matching chars now we will add them even if they don't match.</li>
<li>But post that there is a chance that data will still remain in either of those strings so lets add that as well to the result.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">s1 = &quot;brute&quot;, s2 = &quot;groot&quot;
while(i&gt;0 &amp;&amp; j&gt;0) {
   if(s1.charAt(i-1) == s2.charAt(j-1)) { // if matched then add and reduce both indexes
      result += s1.charAt(i-1);
      i--;
      j--;
   } else if(dp[i-1][j] &gt; dp[i][j]) { // if d[i-1][j] &gt; dp[i][j] then add from first string
      result += s1.charAt(i-1);
      i--;
   }else {
      result += s2.charAt(j-1); // add from second string
      j--;
   }
}

while(i&gt;0) result += s1.charAt(i-1); i--; // add the remaining chars from string 1
while(j&gt;0) result += s2.charAt(j-1); j--; // add the remaining chars from string 2
</code></pre>
<ul>
<li><strong>Distinct Subsequences</strong>: As part of this problem we need to find that how many times string 2 is present in string 1 as a subsequence, there is a slight change with this problem here.<ul>
<li>if the char matches on both string we can consider the index from first string or we can ignore that, means (i-1, j-1) + (i-1, j) </li>
<li>if they don't match just move the first string cause we need to match the first string with second so we do (i-1, j)</li>
</ul>
</li>
</ul>
<pre><code class="language-java">s1 = &quot;babgbag&quot;, s2 = &quot;bag&quot;

if(j&lt;0) return 1; // basically saying s2 is exhausted 
if(i&lt;0) return 0; // nothing to compare 

if(s1.charAt(i) == s.charAt(j))
   return f(i-1, j-1, arr) + f(i-1, j, arr); 

return f(i-1, j, arr); // char is not matching at index so we go for previous index for s1
</code></pre>
<ul>
<li><strong>Edit Distance</strong>: Here we need to calculate min operations required to convert one string to another, we can do delete, insert and replace, to solve this</li>
<li>If both strings match then we move to (i-1, j-1)</li>
<li>If they do not match in that case we take min of (i-1, j) or (i, j-1) or (i-1,j-1) and adding 1 to each</li>
<li><strong>Wildcard matching</strong>: Here we need to match the string with the pattern, like ?ay with ray, **aab with aaab, to solve this</li>
<li>If current char is ? or both strings char match then we move to next index for both f(i-1,j-1)</li>
<li>If current char is * then match the before char on either of those strings meaning f(i-1, j) or f(i, j-1)</li>
<li>for base case as * can be matched to zero or more chars we need to iterate the pattern, if the first string is exhuasted and pattern is still remaining as we can see in the example 2, then we need to check if there is any char apart froom * is left then it is incorrect.</li>
<li><strong>Best Time to Buy and Sell Stock</strong>: </li>
<li>Que: [7, 1, 5, 3, 6, 4] Ans: 5, You can buy only once</li>
<li>Here we will keep track of the min element of the arr and subtract it with the current value.</li>
</ul>
<pre><code class="language-java">   int cost = arr[i]-min;
   profit = Math.max(profit, cost);
   min = Math.min(min, arr[i]);
</code></pre>
<ul>
<li><strong>Best Time to Buy and Sell Stock 2</strong>: </li>
<li>Que: [7, 1, 5, 3, 6, 4] Ans: 7, Here You can buy multiple times</li>
<li>This is similar to take and not take case scenario where we can decide to take the value or we don't, so we need to keep 2 vars one will be index and second will be to know whether we are buying or selling and call this data in recursion</li>
<li>In optimized approach we take 4 vars and do the same.</li>
</ul>
<pre><code class="language-java">   long profit = 0;
   if(buy == 1){
      profit = Math.max(-arr[i] + f(i-1, 0, arr) // take case, here we considered a value so we are saying next time I can only sell
                        0 + f(i-1, 1, arr))      // not take case, here we have decided not to buy and that's why we skipped it
   } else {
      profit = Math.max(arr[i] + f(i-1, 1, arr) // take case, here we considered a value so we are saying next time I can only buy
                        0 + f(i-1, 0, arr))     // not take case, here we have decided not to sell and that's why we skipped it
   }
   return profit;
</code></pre>
<ul>
<li><strong>Best Time to Buy and Sell Stock 3</strong>: </li>
<li>Que: [3,4,5,0,0,3,1,4] Ans: 6, Here you can do at max 2 transactions</li>
<li>Similar to above problem, one change is that we need to maintain a variable which will keep track of the transaction made so far, which we will change based on take case</li>
</ul>
<pre><code class="language-java">   if(i==n || trans == 2*k) return 0; // we did 2*k becauses sell is 1 transaction and buy is 1
   long profit = 0;
   if(trans%2 == 0){
      profit = Math.max(-arr[i] + f(i-1, 0, trans+1, arr) // take case, here we considered a value so we are saying next time I can only sell
                        0 + f(i-1, 1, trans, arr))      // not take case, here we have decided not to buy and that's why we skipped it
   } else {
      profit = Math.max(arr[i] + f(i-1, 1, trans+1, arr) // take case, here we considered a value so we are saying next time I can only buy
                        0 + f(i-1, 0, trans, arr))     // not take case, here we have decided not to sell and that's why we skipped it
   }
   return profit;
</code></pre>
<ul>
<li><strong>Best Time to Buy and Sell Stock 4</strong>: Similar to above, there we had 2 here we have k</li>
<li>Que: [3,4,5,0,0,3,1,4] Ans: 6, Here you can do at max k transactions</li>
<li><strong>Best Time to Buy and Sell Stock with Cooldown</strong>:</li>
<li>Que: [4,9,0,4,10] Ans: 11, You cannot buy after sell</li>
<li>Similar to stock 2 question, here when we sell anything then we will do i-2 instead of i-1 that's it, cause you are not allowed to buy on next day, for take case</li>
<li><strong>Best Time to Buy and Sell Stock With Transaction Fee</strong>:</li>
<li>Que: [4,9,0,4,10] Ans: 11, You need to pay transaction fee post selling</li>
<li>Similar to stock 2 question, here when we are selling that time we will subtract the value from the profit and we are good, for take case</li>
<li><strong>Longest Increasing subsequence</strong>:</li>
<li>For this question we will check if the new value is greater than the prev value then take it add to the result. Similar to take and not take case, just that first we will start with not take case and take the max value and return it.</li>
</ul>
<pre><code class="language-java">
   int len = 0 + f(i+1, prevIndex);                // not take case
   if(prevIndex == -1 || arr[i] &gt; arr[prevIndex])
      len = Math.max(len, f(i+1, i));             // take case  

   return len;
</code></pre>
<ul>
<li><strong>Printing Longest Increasing Subsequence</strong>:</li>
<li>To solve this convert the above ans to dp[1] size,</li>
</ul>
<pre><code class="language-java">
// Step 1 : Loop through dp to find the max length (len) and its last index (ind).

// Step 2: Backtrack to Print LIS
// Start from ind (last element of LIS).
// Move backward and collect elements where dp[i] == len.
// Decrease len each time we add an element.

int i = ind;
List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
while (len &gt; 0) {
    if (dp[i] == len) {
        ans.add(nums[i]);
        len--;
    }
    i--;
}
Collections.reverse(ans);

</code></pre>
<ul>
<li><strong>Longest Increasing subsequence</strong>: Using Binary Search</li>
<li>For this what we can do is create a list in which we will enter the elements if they are greater than the last elemtent of the list, and increase the count.</li>
<li>If it is lesser than the last element then we will get the index at which it should be inserted using binary search. if it is not present then it will return -1 then we need to follow below if case.</li>
</ul>
<pre><code class="language-java">   int pos=Collections.binarySearch(temp,arr[i]);
   if(pos&lt;0){
      pos=Math.abs(pos)-1;
   }
   temp.set(pos,arr[i]);
</code></pre>
<ul>
<li><strong>Largest Divisible Subset</strong>:</li>
<li>Similar to LIS logic, previously we were just checking the number is greater than previous element or not, here first we will sort the array and then we will check if the element is divisible by previous element or not, if it is then we add it. And if we want to print it then we can follow above question's approach</li>
<li><strong>Longest String Chain</strong>:</li>
<li>Similar to LIS logic, previously we were checking the number comparison whether it is greater than the previous one, here we will compare the strings, if the string is not greater in length than the previous one then we will return false, and we will also check if they are both matching or not expect the last char, if both condition satisfy then we are good otherwise we will return false.</li>
<li>Also we need to sort the strings on basis of length, to make sure above logic works</li>
<li><strong>Longest String Chain</strong>: First increasing and then decreasing sequence</li>
<li>Similar to LIS, we need to first start from 0 index and then from length-1 index to get 2 dps, once you have both iterate over then and add the results of both -1 and then you will get the ans.</li>
<li><strong>Number of Longest Increasing Subsequences</strong>:</li>
<li>Similar to LIS, here we need to maintain a count arr which will maintain the count of all the LIS we have so far. If the previous element is greater than the current we assign the old value of count to the new count index, but If the previous dp value + 1 is equal to current dp value in that case we increase the counter value by 1 to the previous value.</li>
</ul>
<pre><code class="language-java">
   for(int i=0; i&lt;n;i++){
      for(int prev=0; prev&lt;i; prev++){
         if(arr[prev] &lt; arr[i] &amp;&amp; 1+dp[prev] &gt; dp[i]) { // condition checking the LIS code which remains the same for all, just some tweak here and there based on ask
            dp[i] = 1+dp[prev];
            count[i] = count[j];
         }else if(arr[prev] &lt; arr[i] &amp;&amp; 1+dp[prev] == dp[i]) { // newly added condition for count
            count[i] = count[j+1]
         }
      }
      max = Math.max(max, dp[i]);
   }

   int nos = 0;
   for(int i=0; i&lt;n;i++)
      if(dp[i] == max) nos += count[i];

   return nos;
</code></pre>
<ul>
<li><strong>Matrix Chain Multiplication</strong>: Partition DP</li>
<li>As part of this problem we have given an matrix where we need to calculate the minimum cost required to multiple the matrices.</li>
<li>Here basically we need to partition the matrices in such a way that it results in min cost, for that we need to introduce the partition DP pattern where we will divide the array using 3 pointers and then we will take the best partition out of all.</li>
<li>Here we introduce new set of rules, which are 
      1) take the base cases 
      2) try out all the partitions
      3) return the min of all (this will change based on the test case).</li>
<li>Now what we do is we break the array in pieces using 3 pointers i, k and j.</li>
<li>i and k will start from the first index of the array and j will be the end of the array. we start from 1st index because we consider first index as row of first matrix, if we don't consider that the result will be 0 as on the 0th index the row size will be 0 and column size will be 10 (if 0th index value is 10);</li>
<li>Once we have done it we will iterate k from i to j to get min steps needed to multiply the matrix.</li>
</ul>
<pre><code class="language-java">
   /**
    * If we want to multiply 2 matrix then the column of first and row of second should match
    * e.g. A = [10][30], B = [30][50]
    * In such cases it is possible to multiply these matrices, so the result will be 10 * 30 * 50
    * **/

   // call
   f(1, n-1, arr); 

   // base case
   if(i==j) return 0; // nothing to multiply with so we return 0

   int min=Integer.MAX_VALUE;

   for(int k = i; k&lt;=j; k++) {
      int cost = arr[i-1] * arr[k] * arr[j] +  // this will change based on the question, as here we need to multiply the matrix so that's why we are doing such operations like 10*20*50  
               f(i, k, arr) +                  // here we start from i to k, the first partition
               f(k+1, j, arr);                 // here we start from k+1 to j, the second partition
      if(cost &lt; min) min=cost;
   }

   return cost;

</code></pre>
<ul>
<li><strong>Minimum Cost to Cut the Stick</strong>: Similar approach like above will be taken where we will divide the problems into partition and get the ans (chololate or rod cutting)</li>
<li>Before starting this problem we need to sort the array</li>
<li>Here again we use 3 pointers to divide the problem into partitions. But in this problem there is one change we can't use the k's value after cutting. Also we will start from 1 and n-2 for i and j.</li>
<li>Why we need to start from 1 we disucssed in last problems as well where we can't start partition from 0 cause there is nothing to cut from it. But here last will also follow the same pattern why because once we cut at last here there will be nothing to compare the value with.</li>
<li>Suppose we have an array [1,3,4,5] with lenght of stick as 7, then if we make a cut at index 0 i.e. of value 1 then the new paritions will be [1] and [1,3,4,5], now for these paritions if we calculate the final cost it will be (last+1) - (start-1) &gt; Let us replaces the values, arr[last+1] - arr[start-1] &gt; 7-0 &gt; as you can see there will be no change in the final result of the length.</li>
<li>Now you ask why 7 and why 0 ... as there are no such values in the array, so what we are seeing is when we go beyond the last length of array we will reach the final length for cut which is nothing but 7, and before starting index 1 there is nothing on which we can cut with so it will be 0.</li>
<li>Here as I already mentioned there is one small change from above problem, we will not cosider the k's value as we have already discussed in approach.</li>
</ul>
<pre><code class="language-java">
   // call
   f(1, n-1, arr); 

   // base case
   if(i&gt;j) return 0; // nothing to return cause it is cross the cut boundary

   int min=Integer.MAX_VALUE;

   for(int k = i; k&lt;=j; k++) {
      int cost = arr[j+1] - arr[i-1] +         // we have already considered k here
               f(i, k-1, arr) +                // here we start from i to k-1, the first partition
               f(k+1, j, arr);                 // here we start from k+1 to j, the second partition
      if(cost &lt; min) min=cost;
   }

   return cost;
</code></pre>
<ul>
<li><strong>Burst Baloons/Mining Diamonds</strong>: Similar approach which we have taken in above example, base case for multiplication will be given in the problem, take the previous * current * next value.</li>
<li>So if we start from 0th index, there is nothing behind it so as we are multiplying we take 1, similar goes for end index. and based on that just a small change will be made to the condition, and we are good to go.</li>
</ul>
<pre><code class="language-java">
   // call
   f(1, n-1, arr); 

   // base case
   if(i&gt;j) return 0; // nothing to return cause it is cross the cut boundary

   int min=Integer.MAX_VALUE;

   for(int k = i; k&lt;=j; k++) {
      int cost = arr[i-1] * arr[k] * arr[j+1] +          // we have already considered k here
               f(i, k-1, arr) +                          // here we start from i to k-1, the first partition
               f(k+1, j, arr);                           // here we start from k+1 to j, the second partition
      if(cost &lt; min) min=cost;
   }

   return cost;
</code></pre>
<ul>
<li><strong>Evaluate Boolean Expression to True</strong>: Similar to partition DP problem, here we will be given an boolean expression and we need to find the total number of ways in which the result will be true</li>
<li>Que: T ^ F | T &amp; F</li>
<li>Again we need to start with partitioning the problem into subproblems with partition DP, also here one more variable will be passed to evaluate true or false values based on the cases.</li>
</ul>
<pre><code class="language-java">
   // call
   f(0, n-1, 1, arr); 

   // base case
   if(i&gt;j) return 0; // nothing to return cause it is cross the cut boundary
   if(i==j){
      if(isTrue == 1) return arr[i] == 'T';
      if(istrue == 0) return arr[i] == 'F';
   }

   int ways=0;

   for(int k = i+1; k&lt;=j-1; k+=2) { // here we need to increase the index by 2 values as we are only interested in the operators
      int lT = f(i, k-1, 1, arr);
      int lF = f(i, k-1, 0, arr);
      int rT = f(k+1, j, 1, arr);
      int rF = f(k+1, j, 0, arr);
      if(arr[k] == '&amp;') {
         if(isTrue==1) ways += lT * rT// only True values will be considered 
         if(isTrue==0) ways += (lT* rF) + (lF * rT) + (lF * rF);
      } else if(arr[k] == '|') {
         // T|T &gt;&gt; T, T|F &gt;&gt; T, F|F &gt;&gt; F 
      } else {
         // T^T &gt;&gt; F, T|F &gt;&gt; T, F|F &gt;&gt; F 
      }
   }

   return ways;
</code></pre>
<ul>
<li><strong>Palindrome Partitioning - II | Front Partition</strong>: This is a new pattern of DP where we do the front partition of the string to find all the substrings which are palindrome in nature.</li>
<li>We start from index 0 and then we check whether this string is palindrome or not if it is one then we increase the count and call the next recurrance by doing index+1.</li>
</ul>
<pre><code class="language-java">
   f(0, n, str); //call

   if(i==n) return 0; // reached at the end of string

   int minCost = Integer.MAX_VALUE;
   String temp = &quot;&quot;;

   for(k=i; k&lt;n; k++) {
      temp += str[k];
      if(isPalindrome(i, k, str)){
         minCost = Math.min(minCost, 1 + f(k+1, n, str)); /// we are doing k+1 because till k we have found that the String is palindrome
      }
   }

   return minCost;
</code></pre>
<ul>
<li><strong>Partition Array for Maximum Sum | Front Partition</strong>: Here we will be given an array from which we can divide it into multiple partitions but of fix size k, and replace that partition's all values with the max value present in that partition and do sum of all and then return the result.</li>
<li>This problem again follows the front partition problem, so here we will again start from index 0 and then take till k elements. </li>
<li>Post that we will multiple the size of partition into the max element in that partition and then return the result</li>
</ul>
<pre><code class="language-java">
   f(0, k, arr); //call

   if(i==arr.length) return 0; // reached at the end of arr

   int max = Integer.MIN_VALUE;
   int len = 0;
   int result = Integer.MIN_VALUE;

   for(j=i; j&lt;Math.min(i+j, arr.length); j++) { // here we will only take max of k elements in an partition, also condition will be evaluated that we are not overflowing the array
      len++;
      max = Math.max(max, arr[j]);              // taking the max element from the parition
      int sum = len * max + f(j+1, k, arr);     // taking sum of all elements from the parition
      result = Math.max(result, sum);          
   }
   return result;
</code></pre>
<ul>
<li><strong>Maximum Rectangle Area with all 1's | DP on Rectangles</strong>: This is a new pattern where we need to find the max area of a matrix which include all the 1's.</li>
<li>Here prerequites are we have solve the largestRectangleArea problem. post that we will call the matrix for all the combintations and then find the max area out of all of them and we are good to go.</li>
</ul>
<pre><code class="language-java">   int[] height = new int[n];
   int maxArea = Integer.MIN_VALUE;

   for(int i=0; i&lt;m; i++) {
      for(int j=0; j&lt;n; j++) {
         if(arr[i][j] == 1) height[j]++;
      }
      int area = largestRectangleArea(height);
      maxArea = Math.max(maxArea, area) ;
   }
   return maxArea;
</code></pre>
<ul>
<li><strong>Count Square Submatrices with All Ones | DP on Rectangles</strong>: </li>
<li>Here we start with recursion and then iterate over all the elements.</li>
<li>we take min of (i-1, j), (i-1,j-1) and (i, j-1) and add 1 to it and store. </li>
<li>Then finally we iterate over the array to get the final result</li>
</ul>
<pre><code class="language-java">   for(int i=0; i&lt;m;i++) dp[i][0] = arr[i][0];
   for(int j=0; j&lt;n;j++) dp[0][j] = arr[0][j];

   for(int i=1; i&lt;m; i++) {
      for(int j=1; j&lt;n; j++) {
         if(arr[i][j] == 0) dp[i][j] = 0;
         else {
            dp[i][j] = 1 + Math.min(dp[i-1][j], Math.min(dp[i-1][j-1], dp[i][j-1]));
         }
      }
   }

   //iterate over dp add all values and return
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.13a4f30d.min.js"></script>
      
    
  </body>
</html>