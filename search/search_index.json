{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\udde0 Data Structures &amp; Algorithms (Java)","text":"<p>Welcome to the DSA Notes site! This documentation covers essential concepts and algorithms in computer science, with examples in Java.</p> <p>Whether you're preparing for interviews, improving problem-solving skills, or just exploring DSA, this guide is for you.</p>"},{"location":"#topics-covered","title":"\ud83d\udcda Topics Covered","text":""},{"location":"#linear-data-structures","title":"\ud83d\udd39 Linear Data Structures","text":"<ul> <li>Array</li> <li>String</li> <li>Stack</li> <li>Queue</li> <li>Linked List</li> </ul>"},{"location":"#non-linear-data-structures","title":"\ud83c\udf32 Non-Linear Data Structures","text":"<ul> <li>Tree</li> <li>Graph</li> <li>Trie</li> </ul>"},{"location":"#algorithms","title":"\u2699\ufe0f Algorithms","text":"<ul> <li>Dynamic Programming</li> <li>Greedy Algorithm</li> </ul>"},{"location":"#techniques-math","title":"\ud83e\uddee Techniques &amp; Math","text":"<ul> <li>Maths</li> <li>Bit Manipulation</li> </ul>"},{"location":"#highlights","title":"\ud83d\udccc Highlights","text":"<ul> <li>\u2705 Clean Java code examples</li> <li>\u2705 Covers foundational to advanced topics</li> <li>\u2705 Structured for quick reference</li> <li>\u2705 Ideal for competitive programming &amp; interviews</li> </ul> <p>\ud83d\udea7 This documentation is a work in progress. Contributions and improvements are welcome!</p>"},{"location":"array/","title":"Array","text":""},{"location":"array/#key-concepts","title":"Key Concepts","text":"<ul> <li>Fixed size, index-based data structure</li> <li>Stored in contiguous memory</li> </ul>"},{"location":"array/#common-problems","title":"Common Problems","text":"<ul> <li>Two Sum</li> <li>Kadane's Algorithm</li> <li>Sliding Window Maximum</li> <li>Merge Intervals</li> </ul>"},{"location":"array/#techniques-patterns","title":"Techniques / Patterns","text":"<ul> <li>Two Pointers</li> <li>Sliding Window</li> <li>Prefix Sum</li> </ul>"},{"location":"array/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"array/#easy","title":"Easy","text":"<ul> <li>Two Sum</li> <li>Maximum Subarray</li> <li>Best Time to Buy and Sell Stock</li> <li>Contains Duplicate</li> <li>Single Number</li> <li>Intersection of Two Arrays II</li> <li>Plus One</li> <li>Move Zeroes</li> <li>Rotate Array</li> <li>Find Pivot Index</li> </ul>"},{"location":"array/#medium","title":"Medium","text":"<ul> <li>3Sum</li> <li>Set Matrix Zeroes</li> <li>Group Anagrams</li> <li>Product of Array Except Self</li> <li>Top K Frequent Elements</li> <li>Sort Colors</li> <li>Find All Numbers Disappeared in an Array</li> </ul>"},{"location":"array/#hard","title":"Hard","text":"<ul> <li>First Missing Positive</li> <li>Trapping Rain Water</li> <li>Merge Intervals</li> <li>Insert Interval</li> <li>Longest Consecutive Sequence</li> <li>Median of Two Sorted Arrays</li> <li>Maximum Product Subarray</li> </ul>"},{"location":"array/#resources","title":"Resources","text":"<ul> <li>LeetCode Array Problems</li> <li>HackerRank Arrays</li> <li>HackerEarth Array Practice</li> </ul>"},{"location":"bit-manipulation/","title":"Bit Manipulation","text":""},{"location":"bit-manipulation/#key-concepts","title":"Key Concepts","text":"<ul> <li>Operations at bit-level for speed and space</li> </ul>"},{"location":"bit-manipulation/#common-problems","title":"Common Problems","text":"<ul> <li>Check if number is power of 2</li> <li>Count set bits</li> <li>Single number in an array</li> </ul>"},{"location":"bit-manipulation/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"bit-manipulation/#easy","title":"Easy","text":"<ul> <li>Single Number</li> </ul>"},{"location":"bit-manipulation/#medium","title":"Medium","text":"<ul> <li>Sum of Two Integers</li> <li>Counting Bits</li> </ul>"},{"location":"bit-manipulation/#hard","title":"Hard","text":"<ul> <li>Maximum XOR of Two Numbers in an Array</li> </ul>"},{"location":"bit-manipulation/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Bit Manipulation</li> </ul>"},{"location":"dynamic-programming/","title":"Dynamic Programming","text":""},{"location":"dynamic-programming/#key-concepts","title":"Key Concepts","text":"<ul> <li>Solves overlapping subproblems</li> <li>Optimal substructure</li> </ul>"},{"location":"dynamic-programming/#common-problems","title":"Common Problems","text":"<ul> <li>Fibonacci Sequence</li> <li>Longest Common Subsequence</li> <li>0/1 Knapsack</li> </ul>"},{"location":"dynamic-programming/#techniques","title":"Techniques","text":"<ul> <li>Memoization (Top-Down)</li> <li>Tabulation (Bottom-Up)</li> </ul>"},{"location":"dynamic-programming/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":"<ul> <li>Climbing Stairs: similar to fibonacci</li> <li>Frog Jump: Similar to above just need to subtract energy to jump (frog need to reach end)<ul> <li>Que: [10,20,30,10] Ans: 20</li> </ul> </li> </ul> <pre><code>      public class ClimbStairsOptimized {\n         public int climbStairs(int n, int arr) {\n\n            int first = 0;\n            int second = 0;\n\n            for (int i = 1; i &lt; n; i++) {\n                  int fs = first + Math.abs(arr[i] - arr[i-1]); // jumping 1 step\n                  int ss = Integer.MAX_VALUE;\n                  if(i&gt;1) ss = second + Math.abs(arr[i] - arr[i-2]); // jumping 2 steps\n\n                  int temp = Math.min(fs, ss); // taking min or max based on question\n                  second = first; \n                  first = temp;\n            }\n\n            return first;\n         }\n      }\n</code></pre> <ul> <li>Frog Jump to K distance: similar to above problem, just one change before we were doing for step 1 and step 2, now we will do till k steps meaning we will iterate min/max logic in a for loop and get the result</li> </ul> <pre><code>for (int i = 1; i &lt; n; i++) {\n   int minSteps = Integer.MAX_VALUE;\n   for(int j = 1; j &lt;= k; j++&gt;) {\n      int ss = Integer.MAX_VALUE;\n      if(i-j&gt;=0) ss = dp[i-j] + Math.abs(arr[i] - arr[i-j]);\n      minSteps = Math.min(fs, ss)\n   }\n   dp[i] = minSteps;\n}\n</code></pre> <ul> <li>Maximum sum of non Adjecent elements: Here as the questions says we can't use contiguos elements for adding up the numbers. So what we do is we start with the classic DP approach of subsequence, where we add element by the take or notTake approach, and solve the problem <ul> <li>Que: [2,1,4,9] Ans: 11</li> </ul> </li> </ul> <pre><code>fun(3, arr);\n\nint fun(int i, int[] arr) {\n   if(i&lt;0) return 0;\n   if(i == 0) return arr[0];\n\n   int take = arr[i] + fun(i-2, arr); // takes the element and will take the next+1 element\n   int notTake = fun(i-1, arr); // does not take, basically says we can take next element\n\n   return Math.max(take, notTake); // return the max value\n}\n</code></pre> <ul> <li>House Robber: Similar to above</li> <li>House Robber 2: Similar to above, here we can't take the first and last element, so we call the method 2 times with [0, n-2] and [1, n-1], means skipping first one time and last second, and then taking max or min as per the expectation</li> <li>Grid Unique Paths</li> <li>Grid Unique Paths 2</li> <li>Min Path Sum</li> <li>Max Path Sum</li> <li>Triangle : Most of these problems will start at a certain index and then move to another in (i-1, j), (i, j-1) or (i-1,j-1) paths. based on questions these change but the core concept remains the same of take and notTake.</li> <li>Cherry Pickup 2 [3D Array]: <ul> <li>Similar to above here 2 start points will be given, core logic remains the same just a change is that when 2 paths collide we will take a single value from both. Also here in function we will have 3 vars instead of 2. Here row remains the same as both start from first row but start index is different that's why. Ending points can be similar, that's why we will take one value if they reach at same index and will take different value if they reach at different indexes. </li> <li>Now as we need to generate all the combinations for 3 pointers we will need a for loop which will start from first person -1 to +1 value and same for second as well.</li> </ul> </li> </ul> <pre><code>\n  return dp(grid, 0, 0, n - 1, mem);\n\n  public int cherryPickup(int[][] grid) {\n    final int m = grid.length;\n    final int n = grid[0].length;\n    int[][][] mem = new int[m][n][n];\n    Arrays.stream(mem).forEach(A -&gt; Arrays.stream(A).forEach(B -&gt; Arrays.fill(B, -1)));\n    return dp(grid, 0, 0, n - 1, mem);\n  }\n\n  // Returns the maximum cherries we can collect, where robot #1 is on (x, y1) and robot #2 is on (x, y2).\n  private int dp(int[][] grid, int x, int y1, int y2, int[][][] mem) {\n    if (x == grid.length) // end of rows\n      return 0;\n    if (y1 &lt; 0 || y1 == grid[0].length || y2 &lt; 0 || y2 == grid[0].length) // out of bounds case\n      return 0;\n    if (mem[x][y1][y2] != -1)\n      return mem[x][y1][y2];\n\n    final int currRow = grid[x][y1] + (y1 == y2 ? 0 : grid[x][y2]); // checking if both match then don't add and take one otherwise add both\n\n    for (int d1 = -1; d1 &lt;= 1; d1++)\n      for (int d2 = -1; d2 &lt;= 1; d2++)\n        mem[x][y1][y2] = Math.max(mem[x][y1][y2], currRow + dp(grid, x + 1, y1 + d1, y2 + d2, mem)); // calling all the 9 combinations here for d1 and d2\n\n    return mem[x][y1][y2];\n  }\n\n</code></pre> <ul> <li>Subset sum equal to K: Mostly similar to problem 4 just that this is 2D, here we will have index and sum and 2 params for our DP. whenever we pass the values just make sure if we are taking it then f(i-1,sum-arr[index]) will be passed otherwise f(i-1, sum) will be passed. Small cases will be added that sum should not be negative when subtracting. </li> <li>Partition Equal Subset Sum:<ul> <li>Que: [2,3,3,3,4,5] must be divided to equal sum &gt; [2,3,5] &amp; [3,3,4]</li> <li>Approach: For this first calculate the total sum fo the array, if sum%2==0 then we can divide it and follow the above problem with Sum as sum/2 and we are good.</li> </ul> </li> <li>Partition A Set Into Two Subsets With Minimum Absolute Sum Difference: This is similar to subset sum problem, where we have create a boolean array which will tell us whether we can get the target sum or not. Now next step is to iterate through the optimized dp solution and subtract s2 = totalSum - s1 and s1 will get the final min value.</li> </ul> <pre><code>   for(int s1 = 0; s1&lt;=totalSum/2;s1++){\n      if(dp[lastRow][s1] == true) // subset sum is possible that means true\n         min = Math.min(min, (totalSum-s1) - s1) // basically saying s2 - s1; as the data will be stored as [0,3,5,7,9,12], for s1 it is from begining and for s2 it from end. \n   }\n</code></pre> <ul> <li>Counts Subsets with Sum K: Similar to problem 12, just we need to all the results if it matches with the sum.</li> <li>Count Partitions With Given Difference:  Similar to problem 12, just a minor change the sum that we will be finding is = (totalSum - diff) / 2</li> <li>0/1 Knapsack: similar to problem 12, here we will be subtracting the weight from the weight capacity of bag, it will break once the loop reaches to end for items.</li> <li>Coin change: Similar to above, just that when we are taking a coin it is not moved to next index for take case if it is less than total value, only for not take case it moved to next index. And as always when we are taking a value that means we need to subtract that value from totalValue. If it reaches to zero then that means we have reached to final.</li> <li>Target Sum: Similar to 16, just a change here is questions is talking about + and - signs which basically means dividing the data into 2 sets.</li> <li>Coin Change 2 | Infinite Supply Problems: Asking for how many ways we can make the amount, just add take and notTake and we will be good.</li> <li>Unbounded Knapsack: Same as coin change problem</li> <li>Rod Cutting Problem: Similar to 0/1 Knapsack problem</li> <li>Longest Common Subsequence: This also follows the approach of match and not match, but here as this is a String problem we will be adding few more cases.</li> </ul> <pre><code>s1 = \"adcbc\", s2 = \"dcadb\"\nif(s1.charAt(i) == s.charAt(j))\n   return 1 + f(i-1, j-1, arr); // As the char matches we go to previous index at both strings\n\nreturn Math.max(f(i, j-1, arr), f(i-1, j, arr)); // char is not matching at index so we go for previous index for s1 and second call for s2 saying that, may be they can match\n</code></pre> <ul> <li>Print Longest Common Subsequence: Similar to above question, go for the optimized solution for above question and then we need to iterate through the dp array with below conditions. Single loop should be enough and start from last indexes of both Strings.<ul> <li>If they match then go to i-1, j-1</li> <li>If they don't match then if dp[i-1][j] &gt; dp[i][j] then i--; else j--;</li> </ul> </li> <li>Longest Common Substring: Similar to LCS problem just that the notTake part is not considered as we want subString not sequence</li> <li>Longest Palindromic Subsequence: Similar to LCS, here for string 2 we need to reverse the original String and send it.</li> <li>Minimum Insertions to Make String Palindrome: Similar to LCS, get the count of above program and subtract from the total size of original string</li> <li>Minimum Insertions/Deletions to Convert String A to String B: s1.size() + s2.size() - 2 * LCS of both</li> <li>Shortest Common Supersequence: <ul> <li>Que : s1=\"brute\", s2=\"groot\" Result: \"bgruoote\"</li> <li>Ans: </li> <li>Approach is similar to 24, just one change is previously we were just printing matching chars now we will add them even if they don't match.</li> <li>But post that there is a chance that data will still remain in either of those strings so lets add that as well to the result.</li> </ul> </li> </ul> <pre><code>s1 = \"brute\", s2 = \"groot\"\nwhile(i&gt;0 &amp;&amp; j&gt;0) {\n   if(s1.charAt(i-1) == s2.charAt(j-1)) { // if matched then add and reduce both indexes\n      result += s1.charAt(i-1);\n      i--;\n      j--;\n   } else if(dp[i-1][j] &gt; dp[i][j]) { // if d[i-1][j] &gt; dp[i][j] then add from first string\n      result += s1.charAt(i-1);\n      i--;\n   }else {\n      result += s2.charAt(j-1); // add from second string\n      j--;\n   }\n}\n\nwhile(i&gt;0) result += s1.charAt(i-1); i--; // add the remaining chars from string 1\nwhile(j&gt;0) result += s2.charAt(j-1); j--; // add the remaining chars from string 2\n</code></pre> <ul> <li>Distinct Subsequences: As part of this problem we need to find that how many times string 2 is present in string 1 as a subsequence, there is a slight change with this problem here.<ul> <li>if the char matches on both string we can consider the index from first string or we can ignore that, means (i-1, j-1) + (i-1, j) </li> <li>if they don't match just move the first string cause we need to match the first string with second so we do (i-1, j)</li> </ul> </li> </ul> <pre><code>s1 = \"babgbag\", s2 = \"bag\"\n\nif(j&lt;0) return 1; // basically saying s2 is exhausted \nif(i&lt;0) return 0; // nothing to compare \n\nif(s1.charAt(i) == s.charAt(j))\n   return f(i-1, j-1, arr) + f(i-1, j, arr); \n\nreturn f(i-1, j, arr); // char is not matching at index so we go for previous index for s1\n</code></pre> <ul> <li>Edit Distance: Here we need to calculate min operations required to convert one string to another, we can do delete, insert and replace, to solve this</li> <li>If both strings match then we move to (i-1, j-1)</li> <li>If they do not match in that case we take min of (i-1, j) or (i, j-1) or (i-1,j-1) and adding 1 to each</li> <li>Wildcard matching: Here we need to match the string with the pattern, like ?ay with ray, **aab with aaab, to solve this</li> <li>If current char is ? or both strings char match then we move to next index for both f(i-1,j-1)</li> <li>If current char is * then match the before char on either of those strings meaning f(i-1, j) or f(i, j-1)</li> <li>for base case as * can be matched to zero or more chars we need to iterate the pattern, if the first string is exhuasted and pattern is still remaining as we can see in the example 2, then we need to check if there is any char apart froom * is left then it is incorrect.</li> <li>Best Time to Buy and Sell Stock: </li> <li>Que: [7, 1, 5, 3, 6, 4] Ans: 5, You can buy only once</li> <li>Here we will keep track of the min element of the arr and subtract it with the current value.</li> </ul> <pre><code>   int cost = arr[i]-min;\n   profit = Math.max(profit, cost);\n   min = Math.min(min, arr[i]);\n</code></pre> <ul> <li>Best Time to Buy and Sell Stock 2: </li> <li>Que: [7, 1, 5, 3, 6, 4] Ans: 7, Here You can buy multiple times</li> <li>This is similar to take and not take case scenario where we can decide to take the value or we don't, so we need to keep 2 vars one will be index and second will be to know whether we are buying or selling and call this data in recursion</li> <li>In optimized approach we take 4 vars and do the same.</li> </ul> <pre><code>   long profit = 0;\n   if(buy == 1){\n      profit = Math.max(-arr[i] + f(i-1, 0, arr) // take case, here we considered a value so we are saying next time I can only sell\n                        0 + f(i-1, 1, arr))      // not take case, here we have decided not to buy and that's why we skipped it\n   } else {\n      profit = Math.max(arr[i] + f(i-1, 1, arr) // take case, here we considered a value so we are saying next time I can only buy\n                        0 + f(i-1, 0, arr))     // not take case, here we have decided not to sell and that's why we skipped it\n   }\n   return profit;\n</code></pre> <ul> <li>Best Time to Buy and Sell Stock 3: </li> <li>Que: [3,4,5,0,0,3,1,4] Ans: 6, Here you can do at max 2 transactions</li> <li>Similar to above problem, one change is that we need to maintain a variable which will keep track of the transaction made so far, which we will change based on take case</li> </ul> <pre><code>   if(i==n || trans == 2*k) return 0; // we did 2*k becauses sell is 1 transaction and buy is 1\n   long profit = 0;\n   if(trans%2 == 0){\n      profit = Math.max(-arr[i] + f(i-1, 0, trans+1, arr) // take case, here we considered a value so we are saying next time I can only sell\n                        0 + f(i-1, 1, trans, arr))      // not take case, here we have decided not to buy and that's why we skipped it\n   } else {\n      profit = Math.max(arr[i] + f(i-1, 1, trans+1, arr) // take case, here we considered a value so we are saying next time I can only buy\n                        0 + f(i-1, 0, trans, arr))     // not take case, here we have decided not to sell and that's why we skipped it\n   }\n   return profit;\n</code></pre> <ul> <li>Best Time to Buy and Sell Stock 4: Similar to above, there we had 2 here we have k</li> <li>Que: [3,4,5,0,0,3,1,4] Ans: 6, Here you can do at max k transactions</li> <li>Best Time to Buy and Sell Stock with Cooldown:</li> <li>Que: [4,9,0,4,10] Ans: 11, You cannot buy after sell</li> <li>Similar to stock 2 question, here when we sell anything then we will do i-2 instead of i-1 that's it, cause you are not allowed to buy on next day, for take case</li> <li>Best Time to Buy and Sell Stock With Transaction Fee:</li> <li>Que: [4,9,0,4,10] Ans: 11, You need to pay transaction fee post selling</li> <li>Similar to stock 2 question, here when we are selling that time we will subtract the value from the profit and we are good, for take case</li> <li>Longest Increasing subsequence:</li> <li>For this question we will check if the new value is greater than the prev value then take it add to the result. Similar to take and not take case, just that first we will start with not take case and take the max value and return it.</li> </ul> <pre><code>\n   int len = 0 + f(i+1, prevIndex);                // not take case\n   if(prevIndex == -1 || arr[i] &gt; arr[prevIndex])\n      len = Math.max(len, f(i+1, i));             // take case  \n\n   return len;\n</code></pre> <ul> <li>Printing Longest Increasing Subsequence:</li> <li>To solve this convert the above ans to dp[1] size,</li> </ul> <pre><code>\n// Step 1 : Loop through dp to find the max length (len) and its last index (ind).\n\n// Step 2: Backtrack to Print LIS\n// Start from ind (last element of LIS).\n// Move backward and collect elements where dp[i] == len.\n// Decrease len each time we add an element.\n\nint i = ind;\nList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();\nwhile (len &gt; 0) {\n    if (dp[i] == len) {\n        ans.add(nums[i]);\n        len--;\n    }\n    i--;\n}\nCollections.reverse(ans);\n\n</code></pre> <ul> <li>Longest Increasing subsequence: Using Binary Search</li> <li>For this what we can do is create a list in which we will enter the elements if they are greater than the last elemtent of the list, and increase the count.</li> <li>If it is lesser than the last element then we will get the index at which it should be inserted using binary search. if it is not present then it will return -1 then we need to follow below if case.</li> </ul> <pre><code>   int pos=Collections.binarySearch(temp,arr[i]);\n   if(pos&lt;0){\n      pos=Math.abs(pos)-1;\n   }\n   temp.set(pos,arr[i]);\n</code></pre> <ul> <li>Largest Divisible Subset:</li> <li>Similar to LIS logic, previously we were just checking the number is greater than previous element or not, here first we will sort the array and then we will check if the element is divisible by previous element or not, if it is then we add it. And if we want to print it then we can follow above question's approach</li> <li>Longest String Chain:</li> <li>Similar to LIS logic, previously we were checking the number comparison whether it is greater than the previous one, here we will compare the strings, if the string is not greater in length than the previous one then we will return false, and we will also check if they are both matching or not expect the last char, if both condition satisfy then we are good otherwise we will return false.</li> <li>Also we need to sort the strings on basis of length, to make sure above logic works</li> <li>Longest String Chain: First increasing and then decreasing sequence</li> <li>Similar to LIS, we need to first start from 0 index and then from length-1 index to get 2 dps, once you have both iterate over then and add the results of both -1 and then you will get the ans.</li> <li>Number of Longest Increasing Subsequences:</li> <li>Similar to LIS, here we need to maintain a count arr which will maintain the count of all the LIS we have so far. If the previous element is greater than the current we assign the old value of count to the new count index, but If the previous dp value + 1 is equal to current dp value in that case we increase the counter value by 1 to the previous value.</li> </ul> <pre><code>\n   for(int i=0; i&lt;n;i++){\n      for(int prev=0; prev&lt;i; prev++){\n         if(arr[prev] &lt; arr[i] &amp;&amp; 1+dp[prev] &gt; dp[i]) { // condition checking the LIS code which remains the same for all, just some tweak here and there based on ask\n            dp[i] = 1+dp[prev];\n            count[i] = count[j];\n         }else if(arr[prev] &lt; arr[i] &amp;&amp; 1+dp[prev] == dp[i]) { // newly added condition for count\n            count[i] = count[j+1]\n         }\n      }\n      max = Math.max(max, dp[i]);\n   }\n\n   int nos = 0;\n   for(int i=0; i&lt;n;i++)\n      if(dp[i] == max) nos += count[i];\n\n   return nos;\n</code></pre> <ul> <li>Matrix Chain Multiplication: Partition DP</li> <li>As part of this problem we have given an matrix where we need to calculate the minimum cost required to multiple the matrices.</li> <li>Here basically we need to partition the matrices in such a way that it results in min cost, for that we need to introduce the partition DP pattern where we will divide the array using 3 pointers and then we will take the best partition out of all.</li> <li>Here we introduce new set of rules, which are        1) take the base cases        2) try out all the partitions       3) return the min of all (this will change based on the test case).</li> <li>Now what we do is we break the array in pieces using 3 pointers i, k and j.</li> <li>i and k will start from the first index of the array and j will be the end of the array. we start from 1st index because we consider first index as row of first matrix, if we don't consider that the result will be 0 as on the 0th index the row size will be 0 and column size will be 10 (if 0th index value is 10);</li> <li>Once we have done it we will iterate k from i to j to get min steps needed to multiply the matrix.</li> </ul> <pre><code>\n   /**\n    * If we want to multiply 2 matrix then the column of first and row of second should match\n    * e.g. A = [10][30], B = [30][50]\n    * In such cases it is possible to multiply these matrices, so the result will be 10 * 30 * 50\n    * **/\n\n   // call\n   f(1, n-1, arr); \n\n   // base case\n   if(i==j) return 0; // nothing to multiply with so we return 0\n\n   int min=Integer.MAX_VALUE;\n\n   for(int k = i; k&lt;=j; k++) {\n      int cost = arr[i-1] * arr[k] * arr[j] +  // this will change based on the question, as here we need to multiply the matrix so that's why we are doing such operations like 10*20*50  \n               f(i, k, arr) +                  // here we start from i to k, the first partition\n               f(k+1, j, arr);                 // here we start from k+1 to j, the second partition\n      if(cost &lt; min) min=cost;\n   }\n\n   return cost;\n\n</code></pre> <ul> <li>Minimum Cost to Cut the Stick: Similar approach like above will be taken where we will divide the problems into partition and get the ans (chololate or rod cutting)</li> <li>Before starting this problem we need to sort the array</li> <li>Here again we use 3 pointers to divide the problem into partitions. But in this problem there is one change we can't use the k's value after cutting. Also we will start from 1 and n-2 for i and j.</li> <li>Why we need to start from 1 we disucssed in last problems as well where we can't start partition from 0 cause there is nothing to cut from it. But here last will also follow the same pattern why because once we cut at last here there will be nothing to compare the value with.</li> <li>Suppose we have an array [1,3,4,5] with lenght of stick as 7, then if we make a cut at index 0 i.e. of value 1 then the new paritions will be [1] and [1,3,4,5], now for these paritions if we calculate the final cost it will be (last+1) - (start-1) &gt; Let us replaces the values, arr[last+1] - arr[start-1] &gt; 7-0 &gt; as you can see there will be no change in the final result of the length.</li> <li>Now you ask why 7 and why 0 ... as there are no such values in the array, so what we are seeing is when we go beyond the last length of array we will reach the final length for cut which is nothing but 7, and before starting index 1 there is nothing on which we can cut with so it will be 0.</li> <li>Here as I already mentioned there is one small change from above problem, we will not cosider the k's value as we have already discussed in approach.</li> </ul> <pre><code>\n   // call\n   f(1, n-1, arr); \n\n   // base case\n   if(i&gt;j) return 0; // nothing to return cause it is cross the cut boundary\n\n   int min=Integer.MAX_VALUE;\n\n   for(int k = i; k&lt;=j; k++) {\n      int cost = arr[j+1] - arr[i-1] +         // we have already considered k here\n               f(i, k-1, arr) +                // here we start from i to k-1, the first partition\n               f(k+1, j, arr);                 // here we start from k+1 to j, the second partition\n      if(cost &lt; min) min=cost;\n   }\n\n   return cost;\n</code></pre> <ul> <li>Burst Baloons/Mining Diamonds: Similar approach which we have taken in above example, base case for multiplication will be given in the problem, take the previous * current * next value.</li> <li>So if we start from 0th index, there is nothing behind it so as we are multiplying we take 1, similar goes for end index. and based on that just a small change will be made to the condition, and we are good to go.</li> </ul> <pre><code>\n   // call\n   f(1, n-1, arr); \n\n   // base case\n   if(i&gt;j) return 0; // nothing to return cause it is cross the cut boundary\n\n   int min=Integer.MAX_VALUE;\n\n   for(int k = i; k&lt;=j; k++) {\n      int cost = arr[i-1] * arr[k] * arr[j+1] +          // we have already considered k here\n               f(i, k-1, arr) +                          // here we start from i to k-1, the first partition\n               f(k+1, j, arr);                           // here we start from k+1 to j, the second partition\n      if(cost &lt; min) min=cost;\n   }\n\n   return cost;\n</code></pre> <ul> <li>Evaluate Boolean Expression to True: Similar to partition DP problem, here we will be given an boolean expression and we need to find the total number of ways in which the result will be true</li> <li>Que: T ^ F | T &amp; F</li> <li>Again we need to start with partitioning the problem into subproblems with partition DP, also here one more variable will be passed to evaluate true or false values based on the cases.</li> </ul> <pre><code>\n   // call\n   f(0, n-1, 1, arr); \n\n   // base case\n   if(i&gt;j) return 0; // nothing to return cause it is cross the cut boundary\n   if(i==j){\n      if(isTrue == 1) return arr[i] == 'T';\n      if(istrue == 0) return arr[i] == 'F';\n   }\n\n   int ways=0;\n\n   for(int k = i+1; k&lt;=j-1; k+=2) { // here we need to increase the index by 2 values as we are only interested in the operators\n      int lT = f(i, k-1, 1, arr);\n      int lF = f(i, k-1, 0, arr);\n      int rT = f(k+1, j, 1, arr);\n      int rF = f(k+1, j, 0, arr);\n      if(arr[k] == '&amp;') {\n         if(isTrue==1) ways += lT * rT// only True values will be considered \n         if(isTrue==0) ways += (lT* rF) + (lF * rT) + (lF * rF);\n      } else if(arr[k] == '|') {\n         // T|T &gt;&gt; T, T|F &gt;&gt; T, F|F &gt;&gt; F \n      } else {\n         // T^T &gt;&gt; F, T|F &gt;&gt; T, F|F &gt;&gt; F \n      }\n   }\n\n   return ways;\n</code></pre> <ul> <li>Palindrome Partitioning - II | Front Partition: This is a new pattern of DP where we do the front partition of the string to find all the substrings which are palindrome in nature.</li> <li>We start from index 0 and then we check whether this string is palindrome or not if it is one then we increase the count and call the next recurrance by doing index+1.</li> </ul> <pre><code>\n   f(0, n, str); //call\n\n   if(i==n) return 0; // reached at the end of string\n\n   int minCost = Integer.MAX_VALUE;\n   String temp = \"\";\n\n   for(k=i; k&lt;n; k++) {\n      temp += str[k];\n      if(isPalindrome(i, k, str)){\n         minCost = Math.min(minCost, 1 + f(k+1, n, str)); /// we are doing k+1 because till k we have found that the String is palindrome\n      }\n   }\n\n   return minCost;\n</code></pre> <ul> <li>Partition Array for Maximum Sum | Front Partition: Here we will be given an array from which we can divide it into multiple partitions but of fix size k, and replace that partition's all values with the max value present in that partition and do sum of all and then return the result.</li> <li>This problem again follows the front partition problem, so here we will again start from index 0 and then take till k elements. </li> <li>Post that we will multiple the size of partition into the max element in that partition and then return the result</li> </ul> <pre><code>\n   f(0, k, arr); //call\n\n   if(i==arr.length) return 0; // reached at the end of arr\n\n   int max = Integer.MIN_VALUE;\n   int len = 0;\n   int result = Integer.MIN_VALUE;\n\n   for(j=i; j&lt;Math.min(i+j, arr.length); j++) { // here we will only take max of k elements in an partition, also condition will be evaluated that we are not overflowing the array\n      len++;\n      max = Math.max(max, arr[j]);              // taking the max element from the parition\n      int sum = len * max + f(j+1, k, arr);     // taking sum of all elements from the parition\n      result = Math.max(result, sum);          \n   }\n   return result;\n</code></pre> <ul> <li>Maximum Rectangle Area with all 1's | DP on Rectangles: This is a new pattern where we need to find the max area of a matrix which include all the 1's.</li> <li>Here prerequites are we have solve the largestRectangleArea problem. post that we will call the matrix for all the combintations and then find the max area out of all of them and we are good to go.</li> </ul> <pre><code>   int[] height = new int[n];\n   int maxArea = Integer.MIN_VALUE;\n\n   for(int i=0; i&lt;m; i++) {\n      for(int j=0; j&lt;n; j++) {\n         if(arr[i][j] == 1) height[j]++;\n      }\n      int area = largestRectangleArea(height);\n      maxArea = Math.max(maxArea, area) ;\n   }\n   return maxArea;\n</code></pre> <ul> <li>Count Square Submatrices with All Ones | DP on Rectangles: </li> <li>Here we start with recursion and then iterate over all the elements.</li> <li>we take min of (i-1, j), (i-1,j-1) and (i, j-1) and add 1 to it and store. </li> <li>Then finally we iterate over the array to get the final result</li> </ul> <pre><code>   for(int i=0; i&lt;m;i++) dp[i][0] = arr[i][0];\n   for(int j=0; j&lt;n;j++) dp[0][j] = arr[0][j];\n\n   for(int i=1; i&lt;m; i++) {\n      for(int j=1; j&lt;n; j++) {\n         if(arr[i][j] == 0) dp[i][j] = 0;\n         else {\n            dp[i][j] = 1 + Math.min(dp[i-1][j], Math.min(dp[i-1][j-1], dp[i][j-1]));\n         }\n      }\n   }\n\n   //iterate over dp add all values and return\n</code></pre>"},{"location":"graph/","title":"Graph","text":""},{"location":"graph/#key-concepts","title":"Key Concepts","text":"<ul> <li>Set of vertices connected by edges</li> <li>Directed/Undirected, Weighted/Unweighted</li> </ul>"},{"location":"graph/#common-problems","title":"Common Problems","text":"<ul> <li>BFS, DFS traversal</li> <li>Detect Cycle</li> <li>Dijkstra's Algorithm</li> </ul>"},{"location":"graph/#algorithms-techniques","title":"Algorithms / Techniques","text":"<ul> <li>BFS, DFS</li> <li>Union-Find</li> <li>Topological Sort</li> </ul>"},{"location":"graph/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"graph/#easy","title":"\u2705 Easy","text":"<ol> <li> <p>Find the Town Judge    Identify a town judge based on trust relationships.</p> </li> <li> <p>Number of Islands    Count connected islands in a grid using DFS/BFS.</p> </li> <li> <p>Flood Fill    Change connected pixels of the same color.</p> </li> <li> <p>Max Area of Island    Find largest connected island area.</p> </li> <li> <p>Clone Graph    Create a deep copy of a graph.</p> </li> </ol>"},{"location":"graph/#medium","title":"\ud83d\udd01 Medium","text":"<ol> <li> <p>Course Schedule    Detect if it\u2019s possible to finish all courses (cycle detection).</p> </li> <li> <p>Number of Connected Components in an Undirected Graph    Count connected components in a graph.</p> </li> <li> <p>Pacific Atlantic Water Flow    Cells from which water flows to both oceans.</p> </li> <li> <p>Alien Dictionary    Find character order from alien dictionary words.</p> </li> <li> <p>Graph Valid Tree    Determine if edges make a valid tree.</p> </li> <li> <p>Number of Islands II    Count islands as land is added dynamically.</p> </li> <li> <p>Word Ladder    Shortest transformation sequence from start to end word.</p> </li> <li> <p>Minimum Height Trees    Find roots of trees with minimum height.</p> </li> </ol>"},{"location":"graph/#hard","title":"\ud83d\udd25 Hard","text":"<ol> <li> <p>Word Ladder II    Find all shortest transformation sequences.</p> </li> <li> <p>Critical Connections in a Network    Find bridges in a network (Tarjan\u2019s algorithm).</p> </li> <li> <p>Reconstruct Itinerary    Rebuild travel itinerary using all tickets.</p> </li> <li> <p>Alien Dictionary II (Similar to Alien Dictionary but more complex variants)</p> </li> <li> <p>Longest Increasing Path in a Matrix    Longest strictly increasing path in a matrix.</p> </li> <li> <p>Cheapest Flights Within K Stops    Find cheapest flight with at most k stops.</p> </li> <li> <p>Shortest Path in a Grid with Obstacles Elimination    Shortest path allowing to eliminate obstacles.</p> </li> </ol>"},{"location":"graph/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Graph Problems</li> <li>HackerRank Graph Theory</li> </ul>"},{"location":"greedy/","title":"Greedy Algorithm","text":""},{"location":"greedy/#key-concepts","title":"Key Concepts","text":"<ul> <li>Local optimal choice leads to global optimum</li> </ul>"},{"location":"greedy/#common-problems","title":"Common Problems","text":"<ul> <li>Activity Selection</li> <li>Fractional Knapsack</li> <li>Jump Game</li> </ul>"},{"location":"greedy/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"greedy/#easy","title":"\u2705 Easy","text":"<ol> <li> <p>Assign Cookies    Assign cookies to children with greedily matching sizes.</p> </li> <li> <p>Jump Game    Determine if you can jump to the last index.</p> </li> <li> <p>Gas Station    Find start point to complete a circular route.</p> </li> <li> <p>Best Time to Buy and Sell Stock    Maximize profit from a single buy/sell.</p> </li> </ol>"},{"location":"greedy/#medium","title":"\ud83d\udd01 Medium","text":"<ol> <li> <p>Partition Labels    Partition a string into as many parts as possible without repeating letters.</p> </li> <li> <p>Task Scheduler    Schedule tasks with cooldown intervals.</p> </li> <li> <p>Jump Game II    Minimum number of jumps to reach the last index.</p> </li> <li> <p>Queue Reconstruction by Height    Reconstruct queue based on height and people in front.</p> </li> <li> <p>Candy    Distribute candies with rules on ratings.</p> </li> </ol>"},{"location":"greedy/#hard","title":"\ud83d\udd25 Hard","text":"<ol> <li> <p>Merge Triplets to Form Target Triplet    Determine if target triplet can be formed from triplets.</p> </li> <li> <p>Minimum Number of Refueling Stops    Minimum stops to reach destination with refueling constraints.</p> </li> <li> <p>Split Array Largest Sum (often solved by binary search + greedy)    Split array to minimize largest sum among subarrays.</p> </li> <li> <p>Largest Divisible Subset    Find largest subset where every pair is divisible.</p> </li> </ol>"},{"location":"greedy/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Greedy Problems</li> </ul>"},{"location":"linked-list/","title":"Linked List","text":""},{"location":"linked-list/#key-concepts","title":"Key Concepts","text":"<ul> <li>Nodes pointing to next element</li> <li>Singly, Doubly, and Circular Linked Lists</li> </ul>"},{"location":"linked-list/#common-problems","title":"Common Problems","text":"<ul> <li>Reverse a Linked List</li> <li>Detect Cycle</li> <li>Merge Two Sorted Lists</li> </ul>"},{"location":"linked-list/#patterns-techniques","title":"Patterns / Techniques","text":"<ul> <li>Fast and Slow Pointers</li> <li>Recursion</li> </ul>"},{"location":"linked-list/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"linked-list/#easy","title":"\u2705 Easy","text":"<ol> <li> <p>Reverse Linked List    Reverse a singly linked list.</p> </li> <li> <p>Merge Two Sorted Lists    Merge two sorted linked lists into one.</p> </li> <li> <p>Delete Node in a Linked List    Delete a node given only access to that node.</p> </li> <li> <p>Remove Nth Node From End of List    Remove the nth node from the end of the list.</p> </li> <li> <p>Linked List Cycle    Detect if a linked list has a cycle.</p> </li> </ol>"},{"location":"linked-list/#medium","title":"\ud83d\udd01 Medium","text":"<ol> <li> <p>Add Two Numbers    Add two numbers represented by linked lists.</p> </li> <li> <p>Sort List    Sort a linked list in O(n log n) time.</p> </li> <li> <p>Copy List with Random Pointer    Deep copy of a linked list with random pointers.</p> </li> <li> <p>Reorder List    Reorder list to a specific sequence.</p> </li> <li> <p>Remove Duplicate from Sorted List II    Remove all duplicates from a sorted linked list.</p> </li> </ol>"},{"location":"linked-list/#hard","title":"\ud83d\udd25 Hard","text":"<ol> <li> <p>Merge k Sorted Lists    Merge k sorted linked lists.</p> </li> <li> <p>Reverse Nodes in k-Group    Reverse nodes in groups of k.</p> </li> <li> <p>LRU Cache (uses linked list + hashmap)    Design a least recently used cache.</p> </li> <li> <p>Split Linked List in Parts    Split linked list into k parts.</p> </li> <li> <p>Copy List with Random Pointer (if considered hard due to pointers)</p> </li> </ol>"},{"location":"linked-list/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Linked List Problems</li> <li>HackerRank Linked Lists</li> </ul>"},{"location":"maths/","title":"Maths","text":""},{"location":"maths/#key-concepts","title":"Key Concepts","text":"<ul> <li>Number theory: GCD, LCM, Primes</li> <li>Modulo operations</li> </ul>"},{"location":"maths/#common-problems","title":"Common Problems","text":"<ul> <li>Sieve of Eratosthenes</li> <li>Modular Exponentiation</li> <li>Count Digits / Bits</li> </ul>"},{"location":"maths/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"maths/#easy","title":"Easy","text":"<ul> <li>Count Primes</li> </ul>"},{"location":"maths/#medium","title":"Medium","text":"<ul> <li>Power of Three</li> <li>Add Digits</li> </ul>"},{"location":"maths/#hard","title":"Hard","text":"<ul> <li>Integer to English Words</li> </ul>"},{"location":"maths/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Math Problems</li> </ul>"},{"location":"queue/","title":"Queue","text":""},{"location":"queue/#key-concepts","title":"Key Concepts","text":"<ul> <li>FIFO (First In First Out)</li> <li>Enqueue and Dequeue operations</li> </ul>"},{"location":"queue/#common-problems","title":"Common Problems","text":"<ul> <li>Implement Queue using Stacks</li> <li>Circular Queue</li> <li>Sliding Window Maximum</li> </ul>"},{"location":"queue/#patterns-techniques","title":"Patterns / Techniques","text":"<ul> <li>Two Stacks for Queue</li> <li>Double-ended Queue (Deque)</li> </ul>"},{"location":"queue/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"queue/#easy","title":"Easy","text":"<ul> <li>Implement Queue using Stacks</li> <li>Number of Recent Calls</li> </ul>"},{"location":"queue/#medium","title":"Medium","text":"<ul> <li>Perfect Squares</li> <li>Dota2 Senate</li> </ul>"},{"location":"queue/#hard","title":"Hard","text":"<ul> <li>Sliding Window Maximum</li> </ul>"},{"location":"queue/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Queue Problems</li> <li>HackerRank Queues</li> </ul>"},{"location":"stack/","title":"Stack","text":""},{"location":"stack/#key-concepts","title":"Key Concepts","text":"<ul> <li>LIFO (Last In First Out)</li> <li>Push and Pop operations</li> </ul>"},{"location":"stack/#common-problems","title":"Common Problems","text":"<ul> <li>Valid Parentheses</li> <li>Next Greater Element</li> <li>Min Stack</li> </ul>"},{"location":"stack/#patterns-techniques","title":"Patterns / Techniques","text":"<ul> <li>Monotonic Stack</li> <li>Stack with auxiliary structures</li> </ul>"},{"location":"stack/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"stack/#easy","title":"Easy","text":"<ul> <li>Valid Parentheses</li> <li>Min Stack</li> </ul>"},{"location":"stack/#medium","title":"Medium","text":"<ul> <li>Evaluate Reverse Polish Notation</li> <li>Daily Temperatures</li> <li>Asteroid Collision</li> <li>Decode String</li> </ul>"},{"location":"stack/#hard","title":"Hard","text":"<ul> <li>Largest Rectangle in Histogram</li> <li>Maximal Rectangle</li> </ul>"},{"location":"stack/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Stack Problems</li> <li>HackerRank Stacks</li> <li>Code360 Stack Questions</li> </ul>"},{"location":"string/","title":"String","text":""},{"location":"string/#key-concepts","title":"Key Concepts","text":"<ul> <li>Immutable sequences of characters</li> <li>Efficient manipulation using StringBuilder</li> <li>Character arrays for performance</li> </ul>"},{"location":"string/#common-problems","title":"Common Problems","text":"<ul> <li>Longest Substring Without Repeating Characters</li> <li>Anagram Check</li> <li>Palindromic Substrings</li> <li>String Compression</li> </ul>"},{"location":"string/#patterns-techniques","title":"Patterns / Techniques","text":"<ul> <li>Sliding Window</li> <li>Two Pointers</li> <li>Hashing</li> </ul>"},{"location":"string/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"string/#easy","title":"\u2705 Easy","text":"<ol> <li> <p>Valid Anagram    Check if two strings are anagrams.</p> </li> <li> <p>Implement strStr()    Find the index of the first occurrence of a substring.</p> </li> <li> <p>Reverse String    Reverse a string in-place.</p> </li> <li> <p>First Unique Character in a String    Find the first non-repeating character.</p> </li> <li> <p>Valid Palindrome    Check if a string is a palindrome ignoring non-alphanumeric chars.</p> </li> </ol>"},{"location":"string/#medium","title":"\ud83d\udd01 Medium","text":"<ol> <li> <p>Longest Substring Without Repeating Characters    Find length of longest substring with unique characters.</p> </li> <li> <p>Group Anagrams    Group strings that are anagrams.</p> </li> <li> <p>Longest Palindromic Substring    Find the longest palindromic substring.</p> </li> <li> <p>Count and Say    Generate the nth term of the count-and-say sequence.</p> </li> <li> <p>Decode String    Decode strings with nested patterns like \"3[a2[c]]\".</p> </li> <li> <p>Minimum Window Substring    Find minimum window substring containing all characters of another string.</p> </li> </ol>"},{"location":"string/#hard","title":"\ud83d\udd25 Hard","text":"<ol> <li> <p>Wildcard Matching    Implement wildcard pattern matching with <code>?</code> and <code>*</code>.</p> </li> <li> <p>Regular Expression Matching    Match strings with regex patterns.</p> </li> <li> <p>Substring with Concatenation of All Words    Find starting indices of substrings formed by concatenating all words.</p> </li> <li> <p>Edit Distance    Compute minimum operations to convert one string to another.</p> </li> <li> <p>Longest Valid Parentheses    Find the length of the longest valid (well-formed) parentheses substring.</p> </li> </ol>"},{"location":"tree/","title":"Tree","text":""},{"location":"tree/#key-concepts","title":"Key Concepts","text":"<ul> <li>Hierarchical structure with nodes</li> <li>Binary Tree, BST, Balanced Trees</li> </ul>"},{"location":"tree/#common-problems","title":"Common Problems","text":"<ul> <li>Tree Traversals (Inorder, Preorder, Postorder)</li> <li>Maximum Depth</li> <li>Lowest Common Ancestor</li> </ul>"},{"location":"tree/#patterns-techniques","title":"Patterns / Techniques","text":"<ul> <li>Recursion</li> <li>DFS, BFS</li> </ul>"},{"location":"tree/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"tree/#easy","title":"\u2705 Easy","text":"<ol> <li> <p>Maximum Depth of Binary Tree    Find the height of a binary tree.</p> </li> <li> <p>Symmetric Tree    Check if a tree is a mirror of itself.</p> </li> <li> <p>Invert Binary Tree    Flip the tree upside down.</p> </li> <li> <p>Binary Tree Paths    Find all root-to-leaf paths.</p> </li> <li> <p>Path Sum    Check if there\u2019s a root-to-leaf path with a given sum.</p> </li> </ol>"},{"location":"tree/#medium","title":"\ud83d\udd01 Medium","text":"<ol> <li> <p>Binary Tree Inorder Traversal    Inorder traversal of a tree (recursive and iterative).</p> </li> <li> <p>Construct Binary Tree from Preorder and Inorder Traversal    Rebuild tree from traversal data.</p> </li> <li> <p>Lowest Common Ancestor of a Binary Search Tree    Find LCA in a BST.</p> </li> <li> <p>Serialize and Deserialize Binary Tree    Convert tree to string and back.</p> </li> <li> <p>Populating Next Right Pointers in Each Node    Connect nodes at the same level.</p> </li> </ol>"},{"location":"tree/#hard","title":"\ud83d\udd25 Hard","text":"<ol> <li> <p>Binary Tree Maximum Path Sum    Find max path sum between any two nodes.</p> </li> <li> <p>Recover Binary Search Tree    Fix swapped nodes in BST.</p> </li> <li> <p>Count of Smaller Numbers After Self    Count smaller elements to the right.</p> </li> <li> <p>Longest Consecutive Sequence    Find longest consecutive path.</p> </li> <li> <p>Word Ladder II (involves graph/tree BFS)</p> </li> </ol>"},{"location":"tree/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Tree Problems</li> <li>HackerRank Trees</li> </ul>"},{"location":"trie/","title":"Trie","text":""},{"location":"trie/#key-concepts","title":"Key Concepts","text":"<ul> <li>Prefix tree structure</li> <li>Efficient for search, autocomplete</li> </ul>"},{"location":"trie/#common-problems","title":"Common Problems","text":"<ul> <li>Insert and Search Word</li> <li>Prefix Matching</li> </ul>"},{"location":"trie/#practice-problems-by-topic","title":"\ud83d\udd39 Practice Problems by Topic","text":""},{"location":"trie/#medium","title":"Medium","text":"<ul> <li>Implement Trie (Prefix Tree)</li> <li>Replace Words</li> </ul>"},{"location":"trie/#hard","title":"Hard","text":"<ul> <li>Word Search II</li> <li>Palindrome Pairs</li> </ul>"},{"location":"trie/#resources","title":"\ud83d\udd39 Resources","text":"<ul> <li>LeetCode Trie Problems</li> </ul>"}]}